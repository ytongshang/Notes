# Array

- %x副词参数，它用于指定以十六进制的格式打印数组或slice全部的元素
- %t副词参数是用于打印布尔型数据
- %T副词参数是用于显示一个值对应的数据类型

- **如果在数组的长度位置出现的是“...”省略号，则表示数组的长度是根据初始化值的个数来计算**
- **数组的初始化还可以用键值对的形式**，这样初始化的顺序就没有关系了

```golang
q := [...]int{1, 2, 3}
fmt.Printf("%T\n", q) // "[3]int"

// 定义了一个含有100个元素的数组r，最后一个元素被初始化为-1，其它元素都是用0初始化
r := [...]int{99: -1}
```

- **当调用一个函数的时候，函数的每个调用参数将会被赋值给函数内部的参数变量，所以函数参数变量接收的是一个复制的副本，并不是原始调用的变量。**
- 因为函数参数传递的机制导致传递大的数组类型将是低效的，并且对数组参数的任何的修改都是发生在复制的数组上，并不能直接修改调用时原始的数组变量

```golang
func zero(ptr *[32]byte) {
    *ptr = [32]byte{}
}
```

- 虽然通过指针来传递数组参数是高效的，而且也允许在函数内部修改数组的值，但是数组依然是僵化的类型，因为数组的类型包含了僵化的长度信息。上面的zero函数并不能接收指向[16]byte类型数组的指针，而且也没有任何添加或删除数组元素的方法。**由于这些原因，除了像SHA256这类需要处理特定大小数组的特例外，数组依然很少用作函数参数；相反，我们一般使用slice来替代数组。**

## Slice

- Slice（切片）代表变长的序列，序列中每个元素都有相同的类型。一个slice类型一般写作[]T，其中T代表slice中元素的类型；slice的语法和数组很像，只是没有固定长度而已
- 一个slice由三个部分构成：指针、长度和容量。
    - 指针指向第一个slice元素对应的底层数组元素的地址，要注意的是slice的第一个元素并不一定就是数组的第一个元素。
    - 容量一般是从slice的开始位置到底层数据的结尾位置
    - 长度对应slice中元素的数目；长度不能超过容量。内置的len和cap函数分别返回slice的长度和容量。

- slice和数组的字面值语法很类似，它们都是用花括弧包含一系列的初始化元素，但是**对于slice并没有指明序列的长度**

```golang
months := [...]string{1: "January", /* ... */, 12: "December"}

Q2 := months[4:7]
summer := months[6:9]
fmt.Println(Q2)     // ["April" "May" "June"]
fmt.Println(summer) // ["June" "July" "August"]
```

- **slice之间不能比较**，因此我们不能使用==操作符来判断两个slice是否含有全部相等元素。
- slice唯一合法的比较操作是和nil比较

```golang
if summer == nil { /* ... */ }
```

- bytes.Equal函数来判断两个字节型slice是否相等（[]byte），但是对于其他类型的slice，我们必须自己展开每个元素进行比较

```golang
func equal(x, y []string) bool {
    if len(x) != len(y) {
        return false
    }
    for i := range x {
        if x[i] != y[i] {
            return false
        }
    }
    return true
}
```

