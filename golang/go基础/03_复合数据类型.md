# 复合数据类型

## 数组

- **如果在数组的长度位置出现的是“...”省略号，则表示数组的长度是根据初始化值的个数来计算**
- **数组的初始化还可以用键值对的形式**，这样初始化的顺序就没有关系了

```golang
q := [...]int{1, 2, 3}   // "[3]int"

// 定义了一个含有100个元素的数组r，最后一个元素被初始化为-1，其它元素都是用0初始化
r := [...]int{99: -1}
```

- **当调用一个函数的时候，函数的每个调用参数将会被赋值给函数内部的参数变量，所以函数参数变量接收的是一个复制的副本，并不是原始调用的变量。**
- 函数参数的值传递机制导致传递大的数组类型低效，并且对数组参数的任何的修改都是发生在复制的数组上，**如果要修改原数组的数据可以传递数组的指针**

```golang
// 置空
func zero(ptr *[32]byte) {
    *ptr = [32]byte{}
}
```

- **除了像SHA256这类需要处理特定大小数组的特例外，数组很少用作函数参数，一般使用slice来替代数组。**

## Slice

- Slice（切片）代表变长的序列，一般写作[]T，slice的语法和数组很像，只是没有固定长度而已
- 一个slice由三个部分构成：指针、长度和容量。
    - **指针指向第一个slice元素对应的底层数组元素的地址**，要注意的是slice的第一个元素并不一定就是数组的第一个元素。
    - **容量一般是从slice的开始位置到底层数据的结尾位置，是有可能小于底层数组的容量的**
    - **长度对应slice中元素的数目**；长度不能超过容量。内置的len和cap函数分别返回slice的长度和容量。

```golang
// 数组
months := [...]string{1: "January", /* ... */, 12: "December"}

// slice
Q2 := months[4:7]
summer := months[6:9]
fmt.Println(Q2)     // ["April" "May" "June"]
fmt.Println(summer) // ["June" "July" "August"]

a := make([]int, 10, 20)
fmt.Printf("cap = %d\n", cap(a)) // cap = 20
b := a[10:]
fmt.Printf("cap = %d\n", cap(b)) // cap = 10，这里并不是20
```

- **slice之间不能比较,slice唯一合法的比较操作是和nil比较**，不能使用==操作符来判断两个slice是否含有全部相等元素。
- bytes.Equal函数来判断两个字节型slice是否相等（[]byte），但是对于其他类型的slice，我们必须自己展开每个元素进行比较

```golang
func equal(x, y []string) bool {
    if len(x) != len(y) {
        return false
    }
    for i := range x {
        if x[i] != y[i] {
            return false
        }
    }
    return true
}
```

### append函数

- 简易版本的appendInt实现

```golang
func AppendInt(x []int, y int) []int {
    var z []int
    xlen := len(x)
    zlen := xlen + 1
    if zlen <= cap(x) {
        z = x[:zlen]
    } else {
        zcap := zlen
        if zcap < 2*xlen {
            zcap = 2 * xlen
        }
        z = make([]int, zlen, zcap)
        copy(z, x)
    }
    z[xlen] = y
    return z
}
```

- **通常我们并不知道append调用是否导致了内存的重新分配**
- **因此我们也不能确认新的slice和原始的slice是否引用的是相同的底层数组空间**
- **我们不能确认在原先的slice上的操作是否会影响到新的slice,通常是将append返回的结果直接赋值给输入的slice变量**

```golang
runes = append(runes, r)
```

- **更新slice变量不仅对调用append函数是必要的，实际上对应任何可能导致长度、容量或底层数组变化的操作都是必要的。**
- **要正确地使用slice，需要记住尽管底层数组的元素是间接访问的，但是slice对应结构体本身的指针、长度和容量部分是直接访问的。要更新这些信息需要像上面例子那样一个显式的赋值操作**

- 内置的append函数则可以追加多个元素，甚至追加一个slice

```golang
var x []int
x = append(x, 1)
x = append(x, 2, 3)
x = append(x, 4, 5, 6)

// “...”省略号表示接收变长的参数为slice
// append the slice x
x = append(x, x...)

// "[1 2 3 4 5 6 1 2 3 4 5 6]"
fmt.Println(x)
```

## Map

- map[K]V, **K必须支持==比较运算符，V可以为任何类型**
- **不要以浮点数作为map的key**
- map上的大部分操作，包括查找、删除、len和range循环都可以安全工作在nil值的map上，它们的行为和一个空的map类似
- **向一个nil值的map存入元素将导致一个panic异常,必须先创建map**
- **禁止对map元素取址**, 原因是map可能随着元素数量的增长而重新分配更大的内存空间，从而可能导致之前的地址无效

```golang

var ages map[string]int  // nil

ages := make(map[string]int)  // 空map
ages := map[string]int{} // 空map
ages = map[string]int{
    "alice":   31,
    "charlie": 34,
}

```

- map不支持比较操作，唯一可以将map与nil进行比较

```golang
func equal(a, b map[string]int) bool {
    if len(a) != len(b) {
        return false
    }
    for ak, av := range a {
        if bv, ok := b[ak]; !ok || av != bv {
            return false
        }
    }
    return true
}
```

- **map的查找key对应的value,如果不存在，则返回value对应的零值,可以用第二个返回值判断是否存在**

```golang
ages = map[string]int{
    "alice":   31,
    "charlie": 34,
}

age, ok := ages["Kael"]
if !ok {
    fmt.Println("the mapped value of Kael not exists")
} else {
    fmt.Println("Kael = " + string(count))
}

// 常联合一起使用
if bobage, ok := ages["bob"]; !ok { /* ... */ }
```

- **Map的迭代顺序是不确定的,如果要按K的顺序输出，则应当手动排序K**

```golang
// 事先定义长度可以减少底层数组的扩容
names := make([]string, 0, len(ages))
for name := range ages {
    names = append(names, name)
}
sort.Strings(names)
for _, name := range names {
    fmt.Printf("%s\t%d\n", name, ages[name])
}
```

- set的实现，**使用value为bool类型的map**

```golang
func main() {
    seen := make(map[string]bool) // a set of strings
    input := bufio.NewScanner(os.Stdin)
    for input.Scan() {
        line := input.Text()
        if !seen[line] {
            seen[line] = true
            fmt.Println(line)
        }
    }

    if err := input.Err(); err != nil {
        fmt.Fprintf(os.Stderr, "dedup: %v\n", err)
        os.Exit(1)
    }
}
```

- map或set的key是slice类型，但是map的key必须是可比较的类型，但是slice并不满足这个条件。
    - **定义一个辅助函数k**，将slice转为map对应的string类型的key，确保只有x和y相等时k(x) == k(y)才成立。
    - **创建一个key为string类型的map**
    - **在每次对map操作时先用k辅助函数将slice转化为string类型**,然后操作对应的map

```golang
var m = make(map[string]int)

func k(list []string) string { return fmt.Sprintf("%q", list) }

func Add(list []string)       { m[k(list)]++ }
func Count(list []string) int { return m[k(list)] }
```

- map的value也可以是一个复合类型

```golang
var graph = make(map[string]map[string]bool)

func addEdge(from, to string) {
    edges := graph[from]
    if edges == nil {
        edges = make(map[string]bool)
        graph[from] = edges
    }
    edges[to] = true
}

func hasEdge(from, to string) bool {
    return graph[from][to]
}
```

## 结构体