# 复合数据类型

## 数组

- **如果在数组的长度位置出现的是“...”省略号，则表示数组的长度是根据初始化值的个数来计算**
- **数组的初始化还可以用键值对的形式**，这样初始化的顺序就没有关系了

```golang
q := [...]int{1, 2, 3}   // "[3]int"

// 定义了一个含有100个元素的数组r，最后一个元素被初始化为-1，其它元素都是用0初始化
r := [...]int{99: -1}
```

- **当调用一个函数的时候，函数的每个调用参数将会被赋值给函数内部的参数变量，所以函数参数变量接收的是一个复制的副本，并不是原始调用的变量。**
- 函数参数的值传递机制导致传递大的数组类型低效，并且对数组参数的任何的修改都是发生在复制的数组上，**如果要修改原数组的数据可以传递数组的指针**

```golang
// 置空
func zero(ptr *[32]byte) {
    *ptr = [32]byte{}
}
```

- **除了像SHA256这类需要处理特定大小数组的特例外，数组很少用作函数参数，一般使用slice来替代数组。**

## Slice

- Slice（切片）代表变长的序列，一般写作[]T，slice的语法和数组很像，只是没有固定长度而已
- 一个slice由三个部分构成：指针、长度和容量。
    - **指针指向第一个slice元素对应的底层数组元素的地址**，要注意的是slice的第一个元素并不一定就是数组的第一个元素。
    - **容量一般是从slice的开始位置到底层数据的结尾位置**
    - **长度对应slice中元素的数目**；长度不能超过容量。内置的len和cap函数分别返回slice的长度和容量。

```golang
// 数组
months := [...]string{1: "January", /* ... */, 12: "December"}

// slice
Q2 := months[4:7]
summer := months[6:9]
fmt.Println(Q2)     // ["April" "May" "June"]
fmt.Println(summer) // ["June" "July" "August"]
```

- **slice之间不能比较,slice唯一合法的比较操作是和nil比较**，不能使用==操作符来判断两个slice是否含有全部相等元素。
- bytes.Equal函数来判断两个字节型slice是否相等（[]byte），但是对于其他类型的slice，我们必须自己展开每个元素进行比较

```golang
func equal(x, y []string) bool {
    if len(x) != len(y) {
        return false
    }
    for i := range x {
        if x[i] != y[i] {
            return false
        }
    }
    return true
}
```

## Map

## 结构体