# 复合数据类型

## 数组

- **如果在数组的长度位置出现的是“...”省略号，则表示数组的长度是根据初始化值的个数来计算**
- **数组的初始化还可以用键值对的形式**，这样初始化的顺序就没有关系了

```golang
q := [...]int{1, 2, 3}   // "[3]int"

// 定义了一个含有100个元素的数组r，最后一个元素被初始化为-1，其它元素都是用0初始化
r := [...]int{99: -1}
```

- **当调用一个函数的时候，函数的每个调用参数将会被赋值给函数内部的参数变量，所以函数参数变量接收的是一个复制的副本，并不是原始调用的变量。**
- 函数参数的值传递机制导致传递大的数组类型低效，并且对数组参数的任何的修改都是发生在复制的数组上，**如果要修改原数组的数据可以传递数组的指针**

```golang
// 置空
func zero(ptr *[32]byte) {
    *ptr = [32]byte{}
}
```

- **除了像SHA256这类需要处理特定大小数组的特例外，数组很少用作函数参数，一般使用slice来替代数组。**

## Slice

- Slice（切片）代表变长的序列，一般写作[]T，slice的语法和数组很像，只是没有固定长度而已
- 一个slice由三个部分构成：指针、长度和容量。
    - **指针指向第一个slice元素对应的底层数组元素的地址**，要注意的是slice的第一个元素并不一定就是数组的第一个元素。
    - **容量一般是从slice的开始位置到底层数据的结尾位置，是有可能小于底层数组的容量的**
    - **长度对应slice中元素的数目**；长度不能超过容量。内置的len和cap函数分别返回slice的长度和容量。

```golang
// 数组
months := [...]string{1: "January", /* ... */, 12: "December"}

// slice
Q2 := months[4:7]
summer := months[6:9]
fmt.Println(Q2)     // ["April" "May" "June"]
fmt.Println(summer) // ["June" "July" "August"]

a := make([]int, 10, 20)
fmt.Printf("cap = %d\n", cap(a)) // cap = 20
b := a[10:]
fmt.Printf("cap = %d\n", cap(b)) // cap = 10，这里并不是20
```

- **slice之间不能比较,slice唯一合法的比较操作是和nil比较**，不能使用==操作符来判断两个slice是否含有全部相等元素。
- bytes.Equal函数来判断两个字节型slice是否相等（[]byte），但是对于其他类型的slice，我们必须自己展开每个元素进行比较

```golang
func equal(x, y []string) bool {
    if len(x) != len(y) {
        return false
    }
    for i := range x {
        if x[i] != y[i] {
            return false
        }
    }
    return true
}
```

### append函数

- 简易版本的appendInt实现

```golang
func AppendInt(x []int, y int) []int {
    var z []int
    xlen := len(x)
    zlen := xlen + 1
    if zlen <= cap(x) {
        z = x[:zlen]
    } else {
        zcap := zlen
        if zcap < 2*xlen {
            zcap = 2 * xlen
        }
        z = make([]int, zlen, zcap)
        copy(z, x)
    }
    z[xlen] = y
    return z
}
```

- **通常我们并不知道append调用是否导致了内存的重新分配**
- **因此我们也不能确认新的slice和原始的slice是否引用的是相同的底层数组空间**
- **我们不能确认在原先的slice上的操作是否会影响到新的slice,通常是将append返回的结果直接赋值给输入的slice变量**

```golang
runes = append(runes, r)
```

- **更新slice变量不仅对调用append函数是必要的，实际上对应任何可能导致长度、容量或底层数组变化的操作都是必要的。**
- **要正确地使用slice，需要记住尽管底层数组的元素是间接访问的，但是slice对应结构体本身的指针、长度和容量部分是直接访问的。要更新这些信息需要像上面例子那样一个显式的赋值操作**

- 内置的append函数则可以追加多个元素，甚至追加一个slice

```golang
var x []int
x = append(x, 1)
x = append(x, 2, 3)
x = append(x, 4, 5, 6)

// “...”省略号表示接收变长的参数为slice
// append the slice x
x = append(x, x...)

// "[1 2 3 4 5 6 1 2 3 4 5 6]"
fmt.Println(x)
```

## Map

- map[K]V, **K必须支持==比较运算符，V可以为任何类型**
- **不要以浮点数作为map的key**
- map上的大部分操作，包括查找、删除、len和range循环都可以安全工作在nil值的map上，它们的行为和一个空的map类似
- **向一个nil值的map存入元素将导致一个panic异常,必须先创建map**
- **禁止对map元素取址**, 原因是map可能随着元素数量的增长而重新分配更大的内存空间，从而可能导致之前的地址无效

```golang

var ages map[string]int  // nil

ages := make(map[string]int)  // 空map
ages := map[string]int{} // 空map
ages = map[string]int{
    "alice":   31,
    "charlie": 34,
}

```

- map不支持比较操作，唯一可以将map与nil进行比较

```golang
func equal(a, b map[string]int) bool {
    if len(a) != len(b) {
        return false
    }
    for ak, av := range a {
        if bv, ok := b[ak]; !ok || av != bv {
            return false
        }
    }
    return true
}
```

- **map的查找key对应的value,如果不存在，则返回value对应的零值,可以用第二个返回值判断是否存在**

```golang
ages = map[string]int{
    "alice":   31,
    "charlie": 34,
}

age, ok := ages["Kael"]
if !ok {
    fmt.Println("the mapped value of Kael not exists")
} else {
    fmt.Println("Kael = " + string(count))
}

// 常联合一起使用
if bobage, ok := ages["bob"]; !ok { /* ... */ }
```

- **Map的迭代顺序是不确定的,如果要按K的顺序输出，则应当手动排序K**

```golang
// 事先定义长度可以减少底层数组的扩容
names := make([]string, 0, len(ages))
for name := range ages {
    names = append(names, name)
}
sort.Strings(names)
for _, name := range names {
    fmt.Printf("%s\t%d\n", name, ages[name])
}
```

- set的实现，**使用value为bool类型的map**

```golang
func main() {
    seen := make(map[string]bool) // a set of strings
    input := bufio.NewScanner(os.Stdin)
    for input.Scan() {
        line := input.Text()
        if !seen[line] {
            seen[line] = true
            fmt.Println(line)
        }
    }

    if err := input.Err(); err != nil {
        fmt.Fprintf(os.Stderr, "dedup: %v\n", err)
        os.Exit(1)
    }
}
```

- map或set的key是slice类型，但是map的key必须是可比较的类型，但是slice并不满足这个条件。
    - **定义一个辅助函数k**，将slice转为map对应的string类型的key，确保只有x和y相等时k(x) == k(y)才成立。
    - **创建一个key为string类型的map**
    - **在每次对map操作时先用k辅助函数将slice转化为string类型**,然后操作对应的map

```golang
var m = make(map[string]int)

func k(list []string) string { return fmt.Sprintf("%q", list) }

func Add(list []string)       { m[k(list)]++ }
func Count(list []string) int { return m[k(list)] }
```

- map的value也可以是一个复合类型

```golang
var graph = make(map[string]map[string]bool)

func addEdge(from, to string) {
    edges := graph[from]
    // 惰性加载
    if edges == nil {
        edges = make(map[string]bool)
        graph[from] = edges
    }
    edges[to] = true
}

func hasEdge(from, to string) bool {
    return graph[from][to]
}
```

## 结构体

- **一个命名为S的结构体类型将不能再包含S类型的成员,但是S类型的结构体可以包含*S指针成员**
- 结构体类型的零值是每个成员都是零值
- 如果结构体没有任何成员的话就是空结构体，写作struct{}

```golang
// 使用空结构体构造set，不过一般不这么写
seen := make(map[string]struct{}) // set of strings
// ...
if _, ok := seen[s]; !ok {
    seen[s] = struct{}{}
    // ...first time seeing s...
}
```

### 结构体初始化

- 结构体的初始化，**无论哪种方法，如果不在定义结构体的包内部，都没法显示初始化未导出的值**
    - 按结构体变量定义的顺序指定**每个变量**的值，只在定义结构体的包内部使用，或者是在较小的结构体中使用
    - 通过成员名字和相应的值来初始化，未指定时使用对应类型的零值

```golang
type Point struct{ X, Y int }
p := Point{1, 2}
p1 := Point{X:1, Y :2}
```

```golang
package p
type T struct{ a, b int } // a and b are not exported

package q
import "p"
var _ = p.T{a: 1, b: 2} // compile error: can't reference a, b
var _ = p.T{1, 2}       // compile error: can't reference a, b
```

- 结构体可以作为函数的参数和返回值，如果考虑效率的话，**较大的结构体通常会用指针的方式传入和返回**
- **如果要在函数内部修改结构体成员的话，用指针传入是必须的；因为在Go语言中，所有的函数参数都是值拷贝传入的，函数参数将不再是函数调用时的原始变量**

```golang
func AwardAnnualRaise(e *Employee) {
    e.Salary = e.Salary * 105 / 100
}

// 结构体一般和指针一起使用，使用这种写法
pp := &Point{1, 2}
```

### 结构体比较

- **如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的**，两个结构体将可以使用==或!=运算符进行比较。**比较运算符==将比较两个结构体的每个成员**
- 可比较的结构体类型和其他可比较的类型一样，可以用于map的key类型

```golang
type Point struct{ X, Y int }

p := Point{1, 2}
q := Point{2, 1}
fmt.Println(p.X == q.X && p.Y == q.Y) // "false"
fmt.Println(p == q)
```

### 匿名成员

- **匿名成员:只声明一个成员对应的数据类型而不指明成员的名字**
- **匿名成员的数据类型必须是命名的类型或指向一个命名的类型的指针**

```golang
type Point struct {
    X int
    Y int
}

type Circle struct {
    Center Point
    Radius int
}

type Wheel struct {
    Circle Circle
    Spokes int
}

// 层级明显，但是调用起来特别麻烦
var w Wheel
w.Circle.Center.X = 8
w.Circle.Center.Y = 8
w.Circle.Radius = 5
w.Spokes = 20
```

- 匿名成员Circle和Point都有自己的名字——就是命名的类型名字——但是这些名字在点操作符中是可选的。
 **我们在访问子成员的时候可以忽略任何匿名成员部分**，其实只是一种语法糖

```golang
type Point struct {
    X int
    Y int
}

type Circle struct {
    Point  // 字段名自动为 Point
    Radius int
}

type Wheel struct {
    Circle // 字段名自动为 Circle
    Spokes int
}

// 匿名成员的特性
var w Wheel
w.X = 8            // equivalent to w.Circle.Point.X = 8
w.Y = 8            // equivalent to w.Circle.Point.Y = 8
w.Radius = 5       // equivalent to w.Circle.Radius = 5
w.Spokes = 20
```

- **结构体初始化并没有简短表示匿名成员的语法**

```golang
w = Wheel{8, 8, 5, 20}                       // compile error: unknown fields
w = Wheel{X: 8, Y: 8, Radius: 5, Spokes: 20} // compile error: unknown fields

w = Wheel{Circle{Point{8, 8}, 5}, 20}

w = Wheel{
    Circle: Circle{
        Point:  Point{X: 8, Y: 8},
        Radius: 5,
    },
    // 因为}是另起一行，所以这里必须加上逗号
    Spokes: 20, // NOTE: trailing comma necessary here (and at Radius)
}
```

- **因为匿名成员也有一个隐式的名字，因此不能同时包含两个类型相同的匿名成员，这会导致名字冲突**
- **因为匿名成员实际上是名字为类型名的成员，所以匿名成员也有可见性的规则约束**

### 匿名类型的方法集

- 简短的点运算符语法可以用于选择匿名成员嵌套的成员，也可以用于访问它们的方法。
- **外层的结构体不仅仅是获得了匿名成员类型的所有成员，而且也获得了该类型导出的全部的方法。**
 这个机制可以用于将一个有简单行为的对象组合成有复杂行为的对象。组合是Go语言中面向对象编程的核心

## JSon

```golang
//编码
func Marshal(v interface{}) ([]byte, error)
func NewEncoder(w io.Writer) *Encoder
func (enc *Encoder) Encode(v interface{}) error

//解码
func Unmarshal(data []byte, v interface{}) error
func NewDecoder(r io.Reader) *Decoder
func (dec *Decoder) Decode(v interface{}) error
```

### 编码

- **默认情况下，转义所有公开的成员，私有成员不转义**

```golang
// Product 商品信息
type Product struct {
    Name      string
    ProductID int64
    Number    int
    Price     float64
    IsOnSale  bool
}

func main() {
    p := &Product{}
    p.Name = "Xiao mi 6"
    p.IsOnSale = true
    p.Number = 10000
    p.Price = 2499.00
    p.ProductID = 1
    data, _ := json.Marshal(p)
    fmt.Println(string(data))
}
```

- 编码相关的struct tag
    - **字段的tag是"-"，那么这个字段不会输出到JSON**
    - **tag中带有自定义名称，那么这个自定义名称会出现在JSON的字段名中**
    - **tag中如果带有"omitempty"选项，那么如果该字段值为对应的零值(比如int的0,bool的false)，就不会输出到JSON串中**
    - **如果字段类型是bool, string, int, int64等，而tag中带有",string"选项，那么这个字段在输出到JSON的时候会把该字段对应的值转换成JSON字符串**

```golang
type Server struct {
    ServerID int      `json:"-"`    //不序列化
    ServerName string `json:"serverName"`  // 名字为小写的serverName
    ServerIP   string `json:"serverIP,omitempty"` // 如果ServerIP为空字符串的话，不序列化
    ServerPrice float64 `json:"serverPrice,string"` // 以string的格式序列化float64类型的参数
}

type Serverslice struct {
    Servers []Server `json:"servers"`
}
```