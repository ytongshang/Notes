# 方法

## 方法声明

- 在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这种类型上，即相当于为这种类型定义了一个独占的方法。
- 函数和方法的区别是指有没有接收器，而不像其他语言那样是指有没有返回值。

```golang
package geometry

import "math"

type Point struct{ X, Y float64 }

// traditional function
func Distance(p, q Point) float64 {
    return math.Hypot(q.X-p.X, q.Y-p.Y)
}

// same thing, but as a method of the Point type
func (p Point) Distance(q Point) float64 {
    return math.Hypot(q.X-p.X, q.Y-p.Y)
}

p := Point{1, 2}
q := Point{4, 6}
fmt.Println(Distance(p, q)) // "5", function call
fmt.Println(p.Distance(q))  // "5", method call
```

- 函数声明前的变量叫作方法接受器，一般命名时选用命名类型的第一个字母

- 在Go语言中，**我们可以给同一个包内的任意命名类型定义方法，只要这个命名类型的底层类型(这个例子里，底层类型是指[]Point这个slice，Path就是命名类型)不是指针或者interface。**

```golang
// A Path is a journey connecting the points with straight lines.
type Path []Point
// Distance returns the distance traveled along the path.
func (path Path) Distance() float64 {
    sum := 0.0
    for i := range path {
        if i > 0 {
            sum += path[i-1].Distance(path[i])
        }
    }
    return sum
}
```

## 基于指针对象的方法

- 当我们需要通过方法更新接受器对象，或者接受者变量本身比较大时，就可以用其指针而不是对象来声明方法

```golang
//方法的名字是 (*Point).ScaleBy
func (p *Point) ScaleBy(factor float64) {
    p.X *= factor
    p.Y *= factor
}
```

- 在现实的程序里，**一般会约定如果Point这个类有一个指针作为接收器的方法，那么所有Point的方法都必须有一个指针接收器**，即使是那些并不需要这个指针接收器的函数

- **不管你的方法的接受器是指针类型还是非指针类型，都是可以通过指针/非指针类型进行调用的，编译器会帮你做类型转换**

```golang
func (p *Point) ScaleBy(factor float64) {
    p.X *= factor
    p.Y *= factor
}

r := &Point{1, 2}
r.ScaleBy(2)
fmt.Println(*r) // "{2, 4}"

// 编译器会做转换
p := Point{1, 2}
p.ScaleBy(2)
fmt.Println(p) // "{2, 4}"

// 方法接受器是指针，而Point{1, 2}只是一个临时变量，不能对其取地址，所以编译错误
Point{1, 2}.ScaleBy(2) // compile error: can't take address of Point literal
```

- 在声明一个方法的接受器该是指针还是非指针类型时，你需要考虑两方面：
    - **第一方面是这个对象本身是不是特别大**，如果声明为非指针变量时，调用会产生一次拷贝；
    - **第二方面是如果你用指针类型作为接受器，那么你一定要注意，就算你对其进行了拷贝，这种指针类型指向的始终是一块内存地址**

- **nil也是一个合法的接收器类型**,就像一些函数允许nil指针作为参数一样，方法理论上也可以用nil指针作为其接收器，尤其当nil对于对象来说是合法的零值时，比如map或者slice

```golang
type IntList struct {
    Value int
    Tail  *IntList
}
// Sum returns the sum of the list elements.
func (list *IntList) Sum() int {
    if list == nil {
        return 0
    }
    return list.Value + list.Tail.Sum()
}
```

## 通过嵌入结构体来扩展类型

- 匿名字段方法

```golang
struct {
    T1       // 字段名自动为 T1
    *T2      // 字段名自动为 T2
    P.T3     // 字段名自动为 T3
    *P.T4    // 字段名自动为 T4
    x, yint  // 非匿名字段 x ， y
}
```

- 如果构体 S，包含一个匿名字段 T，那么这个结构体 S 就有了 T的方法。
- 如果包含的匿名字段为 *T，那么这个结构体 S 就有了 *T 的方法。
- 如果S包含的匿名字段为 T或*T，那么 *S就有了 *T的方法。

```golang
type Point struct{ X, Y float64 }

func (p Point) Distance(q Point) float64 {
    return math.Hypot(q.X-p.X, q.Y-p.Y)
}

func (p *Point) ScaleBy(factor float64) {
    p.X *= factor
    p.Y *= factor
}

type ColoredPoint struct {
    Point
    Color color.RGBA
}

// 匿名字段
var cp ColoredPoint
cp.X = 1
fmt.Println(cp.Point.X) // "1"
cp.Point.Y = 2
fmt.Println(cp.Y) // "2"

red := color.RGBA{255, 0, 0, 255}
blue := color.RGBA{0, 0, 255, 255}
var p = ColoredPoint{Point{1, 1}, red}
var q = ColoredPoint{Point{5, 4}, blue}
fmt.Println(p.Distance(q.Point)) // "5"
p.ScaleBy(2)
q.ScaleBy(2)
fmt.Println(p.Distance(q.Point)) // "10"

// 并不是继承的关系而是组合的关系
p.Distance(q) // compile error: cannot use q (ColoredPoint) as Point
```

- 一个ColoredPoint并不是一个Point，但它"has a"Point，**是组合而非继承的关系，并且它有从Point类里引入的Distance和ScaleBy方法。**
 内嵌字段会指导编译器去生成额外的包装方法来委托已经声明好的方法

```golang
func (p ColoredPoint) Distance(q Point) float64 {
    return p.Point.Distance(q)
}

func (p *ColoredPoint) ScaleBy(factor float64) {
    p.Point.ScaleBy(factor)
}
```

- **在类型中内嵌的匿名字段也可能是一个命名类型的指针，这种情况下字段和方法会被间接地引入到当前的类型中，访问需要通过该指针指向的对象去取**。
 添加这一层间接关系让我们可以共享通用的结构并动态地改变对象之间的关系
- 当编译器解析一个选择器到方法时，比如p.ScaleBy，
    - 它会首先去找直接定义在这个类型里的ScaleBy方法
    - 然后找被ColoredPoint的内嵌字段们引入的方法，去找Point和RGBA的内嵌字段引入的方法
    - 然后一直递归向下找。
    - 如果选择器有二义性的话编译器会报错，比如你在同一级里有两个同名的方法

### 匿名字段暴露方法的优先级

- [匿名字段暴露方法的优先级](http://blog.csdn.net/typ2004/article/details/41605083)

```golang
type gzipResponseWriterstruct {
// io.Writer这个接口已经有 Write方法了，http.ResponseWriter 同样有 Write方法。那么///对 g.Write写的时候，到底调用哪个呢？是 g.Writer.Write 还是 g.ResponseWriter.Write呢？你不知道程序也不知道，如果编译就出现“Write模糊不清”的错误。
    io.Writer
    http.ResponseWriter
}
```

- **解决办法1：就是重写 gzipResponseWriter的 Write方法**，指明要写到哪一方

```golang
func (w gzipResponseWriter) Write(b []byte) (int, os.Error) {
    returnw.Writer.Write(b)
}
```

- **解决办法2：使用匿名字段暴露方法优先级来确定重复方法的时候使用哪一个方法，原则就是【简单优先】**。所以我们这里把 http.ResponseWriter弄复杂一点，使用另一个结构体先包裹一次,这样就是 io.Writer的方法是会优先暴露出来的

```golang
type responseWriter struct {
    http.ResponseWriter
}

type gzipResponseWriterstruct {
    io.Writer
    responseWriter
}
```

## 方法值和方法表达式

- **当调用一个方法时**，与调用一个普通的函数相比，**我们必须要用选择器(p.Distance)语法来指定方法的接收器**
- p.Distance叫作“选择器”，选择器会返回一个**方法"值"->一个将方法(Point.Distance)绑定到特定接收器变量的函数**

```golang
p := Point{1, 2}
q := Point{4, 6}

distanceFromP := p.Distance        // method value
fmt.Println(distanceFromP(q))      // "5"
var origin Point                   // {0, 0}
fmt.Println(distanceFromP(origin)) // "2.23606797749979", sqrt(5)

scaleP := p.ScaleBy // method value
scaleP(2)           // p becomes (2, 4)
scaleP(3)           // then (6, 12)
scaleP(10)
```

```golang
type Rocket struct { /* ... */ }
func (r *Rocket) Launch() { /* ... */ }
r := new(Rocket)
time.AfterFunc(10 * time.Second, func() { r.Launch() })
// 使用方法值
time.AfterFunc(10 * time.Second, r.Launch)
```

- **当T是一个类型时，方法表达式可能会写作T.f或者(*T).f，会返回一个方法表达式，这种函数会将其第一个参数用作接收器，后面紧跟原方法的参数，可以用不写选择器的方式来对其进行调用**

```golang
p := Point{1, 2}
q := Point{4, 6}

distance := Point.Distance   // method expression
fmt.Println(distance(p, q))  // "5"
fmt.Printf("%T\n", distance) // "func(Point, Point) float64"

scale := (*Point).ScaleBy
scale(&p, 2)
fmt.Println(p)            // "{2 4}"
fmt.Printf("%T\n", scale) // "func(*Point, float64)"

// 这个Distance实际上是指定了Point对象为接收器的一个方法func (p Point) Distance()，
// 通过Point.Distance得到的函数需要比实际的Distance方法多一个参数，
// 即其需要用第一个额外参数指定接收器，后面排列Distance方法的参数。
```

```golang
type Point struct{ X, Y float64 }

func (p Point) Add(q Point) Point { return Point{p.X + q.X, p.Y + q.Y} }
func (p Point) Sub(q Point) Point { return Point{p.X - q.X, p.Y - q.Y} }

type Path []Point

func (path Path) TranslateBy(offset Point, add bool) {
    var op func(p, q Point) Point
    if add {
        op = Point.Add
    } else {
        op = Point.Sub
    }
    for i := range path {
        // Call either path[i].Add(offset) or path[i].Sub(offset).
        path[i] = op(path[i], offset)
    }
}
```
