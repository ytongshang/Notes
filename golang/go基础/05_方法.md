# 方法

## 方法声明

- 在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这种类型上，即相当于为这种类型定义了一个独占的方法。

```golang
package geometry

import "math"

type Point struct{ X, Y float64 }

// traditional function
func Distance(p, q Point) float64 {
    return math.Hypot(q.X-p.X, q.Y-p.Y)
}

// same thing, but as a method of the Point type
func (p Point) Distance(q Point) float64 {
    return math.Hypot(q.X-p.X, q.Y-p.Y)
}

p := Point{1, 2}
q := Point{4, 6}
fmt.Println(Distance(p, q)) // "5", function call
fmt.Println(p.Distance(q))  // "5", method call
```

- 函数声明前的变量叫作方法接受器，一般命名时选用命名类型的第一个字母

- 在Go语言中，**我们可以给同一个包内的任意命名类型定义方法，只要这个命名类型的底层类型(这个例子里，底层类型是指[]Point这个slice，Path就是命名类型)不是指针或者interface。**

```golang
// A Path is a journey connecting the points with straight lines.
type Path []Point
// Distance returns the distance traveled along the path.
func (path Path) Distance() float64 {
    sum := 0.0
    for i := range path {
        if i > 0 {
            sum += path[i-1].Distance(path[i])
        }
    }
    return sum
}
```

## 基于指针对象的方法

- 当我们需要通过方法更新接受器对象，或者接受者变量本身比较大时，就可以用其指针而不是对象来声明方法

```golang
//方法的名字是 (*Point).ScaleBy
func (p *Point) ScaleBy(factor float64) {
    p.X *= factor
    p.Y *= factor
}
```

- 在现实的程序里，**一般会约定如果Point这个类有一个指针作为接收器的方法，那么所有Point的方法都必须有一个指针接收器**，即使是那些并不需要这个指针接收器的函数

- **不管你的方法的接受器是指针类型还是非指针类型，都是可以通过指针/非指针类型进行调用的，编译器会帮你做类型转换**

```golang
func (p *Point) ScaleBy(factor float64) {
    p.X *= factor
    p.Y *= factor
}

r := &Point{1, 2}
r.ScaleBy(2)
fmt.Println(*r) // "{2, 4}"

// 编译器会做转换
p := Point{1, 2}
p.ScaleBy(2)
fmt.Println(p) // "{2, 4}"

// 方法接受器是指针，而Point{1, 2}只是一个临时变量，不能对其取地址，所以编译错误
Point{1, 2}.ScaleBy(2) // compile error: can't take address of Point literal
```

- 在声明一个方法的接受器该是指针还是非指针类型时，你需要考虑两方面：
    - **第一方面是这个对象本身是不是特别大**，如果声明为非指针变量时，调用会产生一次拷贝；
    - **第二方面是如果你用指针类型作为接受器，那么你一定要注意，就算你对其进行了拷贝，这种指针类型指向的始终是一块内存地址**

- **nil也是一个合法的接收器类型**,就像一些函数允许nil指针作为参数一样，方法理论上也可以用nil指针作为其接收器，尤其当nil对于对象来说是合法的零值时，比如map或者slice

```golang
type IntList struct {
    Value int
    Tail  *IntList
}
// Sum returns the sum of the list elements.
func (list *IntList) Sum() int {
    if list == nil {
        return 0
    }
    return list.Value + list.Tail.Sum()
}
```

## 通过嵌入结构体来扩展类型

- 匿名字段方法

```golang
struct {
    T1       // 字段名自动为 T1
    *T2      // 字段名自动为 T2
    P.T3     // 字段名自动为 T3
    *P.T4    // 字段名自动为 T4
    x, yint  // 非匿名字段 x ， y
}
```

- 如果构体 S，包含一个匿名字段 T，那么这个结构体 S 就有了 T的方法。
- 如果包含的匿名字段为 *T，那么这个结构体 S 就有了 *T 的方法。
- 如果S包含的匿名字段为 T或*T，那么 *S就有了 *T的方法。

```golang
type Point struct{ X, Y float64 }

func (p Point) Distance(q Point) float64 {
    return math.Hypot(q.X-p.X, q.Y-p.Y)
}

func (p *Point) ScaleBy(factor float64) {
    p.X *= factor
    p.Y *= factor
}

type ColoredPoint struct {
    Point
    Color color.RGBA
}

// 匿名字段
var cp ColoredPoint
cp.X = 1
fmt.Println(cp.Point.X) // "1"
cp.Point.Y = 2
fmt.Println(cp.Y) // "2"

red := color.RGBA{255, 0, 0, 255}
blue := color.RGBA{0, 0, 255, 255}
var p = ColoredPoint{Point{1, 1}, red}
var q = ColoredPoint{Point{5, 4}, blue}
fmt.Println(p.Distance(q.Point)) // "5"
p.ScaleBy(2)
q.ScaleBy(2)
fmt.Println(p.Distance(q.Point)) // "10"

// 并不是继承的关系而是组合的关系
p.Distance(q) // compile error: cannot use q (ColoredPoint) as Point
```

- 一个ColoredPoint并不是一个Point，但它"has a"Point，**是组合而非继承的关系，并且它有从Point类里引入的Distance和ScaleBy方法。**
 内嵌字段会指导编译器去生成额外的包装方法来委托已经声明好的方法

```golang
func (p ColoredPoint) Distance(q Point) float64 {
    return p.Point.Distance(q)
}

func (p *ColoredPoint) ScaleBy(factor float64) {
    p.Point.ScaleBy(factor)
}
```

- **在类型中内嵌的匿名字段也可能是一个命名类型的指针，这种情况下字段和方法会被间接地引入到当前的类型中，访问需要通过该指针指向的对象去取**。
 添加这一层间接关系让我们可以共享通用的结构并动态地改变对象之间的关系
- 当编译器解析一个选择器到方法时，比如p.ScaleBy，
    - 它会首先去找直接定义在这个类型里的ScaleBy方法
    - 然后找被ColoredPoint的内嵌字段们引入的方法，去找Point和RGBA的内嵌字段引入的方法
    - 然后一直递归向下找。
    - 如果选择器有二义性的话编译器会报错，比如你在同一级里有两个同名的方法

### 匿名字段暴露方法的优先级

- [匿名字段暴露方法的优先级](http://blog.csdn.net/typ2004/article/details/41605083)

```golang
type gzipResponseWriterstruct {
// io.Writer这个接口已经有 Write方法了，http.ResponseWriter 同样有 Write方法。那么///对 g.Write写的时候，到底调用哪个呢？是 g.Writer.Write 还是 g.ResponseWriter.Write呢？你不知道程序也不知道，如果编译就出现“Write模糊不清”的错误。
    io.Writer
    http.ResponseWriter
}
```

- **解决办法1：就是重写 gzipResponseWriter的 Write方法**，指明要写到哪一方

```golang
func (w gzipResponseWriter) Write(b []byte) (int, os.Error) {
    returnw.Writer.Write(b)
}
```

- **解决办法2：使用匿名字段暴露方法优先级来确定重复方法的时候使用哪一个方法，原则就是【简单优先】**。所以我们这里把 http.ResponseWriter弄复杂一点，使用另一个结构体先包裹一次,这样就是 io.Writer的方法是会优先暴露出来的

```golang
type responseWriter struct {
    http.ResponseWriter
}

type gzipResponseWriterstruct {
    io.Writer 
    responseWriter
}
```