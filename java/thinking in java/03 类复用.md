# 类复用

- [构造函数](#构造函数)
- [清理函数](#清理函数)
- [名称屏蔽](#名称屏蔽)
- [protected](#protected)
- [final](#final)
- [代理](#代理)

## 类复用的方式

- 复用类：组合，继承，代理
- 即使一个类只有包访问权限，其public main依然是可以访问的

## 构造函数

- 初始化类对象的三个地方：
    - 在对象定义的地方，它们总是在构造器被调用之前初始化;
    - 构造函数；
    - 使用对象之前，惰性加载

- **导出类初始化，总是先初始化基类**，类的构造是从基类向外扩散的，所以**基类在导出类构造器可以访问它之前，已经完成了初始化**
- 如果基类没有构造函数或者有默认构造函数，导出类的构造函数就不必明确调用基类构造函数，否则必须用super调用父类的构造函数

## 清理函数

- 一般不必写清理函数，但如果要清理除了内存以外的动作时，要写清理函数
- **如果要写的话，首先要执行导出类的特定清理动作，其清理顺序与初始化的顺序相反，然后才调用其基类的清理方法**
- 不要直接使用finalize()方法

## 名称屏蔽

- 与C++不同，如果java基类拥有多次被重载的方法名称，在**导出类重新定义该方法名称并不会屏蔽其在基类中的任何版本**

## protected

- 就类的用户而言，protected相当于private
- 对于该类的导出类与同一个包的类而言，它却是可以被访问的
- **protected也提供了包访问权**

## final

- final基类类型，其值不变，
- final对象，其引用恒定不变
- 空白final，声明为final,但定义时未初始化，必须在构造函数初始化
- final方法，保证不被覆盖，所以有private方法隐式是final的，
 继承体系中，子类可以重新定义一个与其类相同签名的，在基类中是private的方法，但这并不是方法覆盖，而是两个不同的方法
- final类，不允许继承

## 代理

- 数据的存储方式等同于组合
- 但对外暴露出了内部对象的所有接口
