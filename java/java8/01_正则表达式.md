# 正则表达式

## Pattern

- Pattern 类包含多个标志(int 类型),这些标志可以控制Pattern 匹配模式的方式。上面代码中的标志使模式匹配忽略大小写

```java
String text = "This is the text to be searched " + "for occurrences of the http:// pattern.";
String patternString = ".*http://.*";

Pattern pattern = Pattern.compile(patternString, Pattern.CASE_INSENSITIVE);
```

- 一旦获得了Pattern对象，接着可以获得Matcher对象。Matcher 示例用于匹配文本中的模式.

```java
Matcher matcher = pattern.matcher(text);
```

- Pattern.split(),Pattern 类的 split()方法，可以用正则表达式作为分隔符，把文本分割为String类型的数组

```java
String text = "A sep Text sep With sep Many sep Separators";
String patternString = "sep";
Pattern pattern = Pattern.compile(patternString);
String[] split = pattern.split(text);
System.out.println("split.length = " + split.length);
for(String element : split){
System.out.println("element = " + element);
}
```

- Pattern对象是不可变对象，可以在多线程中安全使用

## Matcher

###  Matches/LookingAt/find

- matches:整个匹配，只有整个字符序列完全匹配成功，才返回True，否则返回False。**但如果前部分匹配成功，将移动下次匹配的位置。**
- lookingAt:部分匹配，**总是从第一个字符进行匹配**,匹配成功了不再继续匹配，匹配失败了,也不继续匹配。
- find:部分匹配，从当前位置开始匹配，**找到一个匹配的子串，将移动下次匹配的位置。**
    
### Reset

- reset() 方法会重置Matcher 内部的 匹配状态。当find() 方法开始匹配时,Matcher 内部会记录截至当前查找的距离。调用 reset() 会重新从文本开头查找。
   - 也可以调用 reset(CharSequence) 方法. 这个方法重置Matcher,同时把一个新的字符串作为参数传入，用于代替创建 Matcher 的原始字符串。
    
```java
public class RegexTest2 {
    public static void main(String[] args){
        test();
    }
    
    public static void test() {
        Pattern pattern = Pattern.compile("\\d{3,5}");
        String charSequence = "123-34345-234-00";
        Matcher matcher = pattern.matcher(charSequence);
 
        //虽然匹配失败，但由于charSequence里面的"123"和pattern是匹配的,所以下次的匹配从位置4开始
        print(matcher.matches());
        //测试匹配位置
        matcher.find();
        print(matcher.start());
 
        //使用reset方法重置匹配位置
        matcher.reset();
 
        //第一次find匹配以及匹配的目标和匹配的起始位置
        print(matcher.find());
        print(matcher.group()+" - "+matcher.start());
        //第二次find匹配以及匹配的目标和匹配的起始位置
        print(matcher.find());
        print(matcher.group()+" - "+matcher.start());
 
        //第一次lookingAt匹配以及匹配的目标和匹配的起始位置
        print(matcher.lookingAt());
        print(matcher.group()+" - "+matcher.start());
 
        //第二次lookingAt匹配以及匹配的目标和匹配的起始位置
        print(matcher.lookingAt());
        print(matcher.group()+" - "+matcher.start());
    }
    
    
    public static void print(Object o){
        System.out.println(o);
    }
}
    
// false 4 true 123 - 0 true 34345 - 4 true 123 - 0 true 123 - 0****
```

### find/start/end

- find() 方法用于在文本中查找出现的正则表达式，如果在文本中多次匹配，find() 方法返回第一个，之后每次调用 find() 都会返回下一个。
- start() 和 end() 返回每次匹配的字串在整个文本中的开始和结束位置。实际上, end() 返回的是字符串末尾的后一位，这样，可以在把 start() 和 end() 的返回值直接用在String.substring() 里。

```java
String text    =
        "This is the text which is to be searched " +
        "for occurrences of the word 'is'.";
String patternString = "is";
Pattern pattern = Pattern.compile(patternString);
Matcher matcher = pattern.matcher(text);
int count = 0;
while(matcher.find()) {
    count++;
    System.out.println("found: " + count + " : "  + matcher.start() + " - " + matcher.end());
}
```

### group




























