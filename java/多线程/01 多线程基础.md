# 多线程

- [线程的状态](#线程的状态)
- [线程sleep()](#线程sleep)
- [线程优先级](#线程优先级)
- [线程yield()](#线程yield)
- [线程 join()](#线程-join)
- [后台线程](#后台线程)
- [异常](#异常)
- [使用Executor管理thread对象](#使用executor管理thread对象)
- [从任务中返回值](#从任务中返回值)
- [解决共享资源兑争](#解决共享资源兑争)
- [同步与锁](#同步与锁)
- [线程阻塞](#线程阻塞)
- [原子性与可见性](#原子性与可见性)
- [临界区](#临界区)
- [在其它对象上同步](#在其它对象上同步)
- [ThreadLocal](#threadlocal)


- 进程是运行在它自己的地址空间内的自包容程序
- 一个线程就是在进程中的一个顺序控制流

## 线程的状态

- 线程状态简图

![线程状态](../../image-resources/thread_status.png)

- **新状态**：线程对象已经创建，还没有在其上调用start()方法。

- **可运行状态**：当线程有资格运行，但调度程序还没有把它选定为运行线程时线程所处的状态。当start() 方法调用时，线程首先进入可运行状态。在线程运行之后或者从阻塞、等待或睡眠状态回来后，也返回到可 运行状态。

- **运行状态**：线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一一种方式。
 等待/阻塞/睡眠状态：这是线程有资格运行时它所处的状态。实际上这个三状态组合为一种，其共同点是：线程仍旧是活的，但是当前没有条件运行。换句话说，它是可运行的，但是如果某件事件出现，他可能返回到可运行状态。

- **死亡态**：当线程的run()方法完成时就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生.如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。

- **使线程离开运行状态的方法**：
    - 调用Thread.sleep()：使当前线程至少睡眠这个时间（尽管它可能在指定的时间之前被中断）;
    - 调用Thread.yield()：不能保障太多事情，尽管通常它会让当前运行线程回到可运行性状态，使得有相同优先级的线程有机会执行;
    - 调用join()方法：保证当前线程停止执行，直到该线程所加入的线程完成为止。然而，如果它加入的线程没有存活，则当前线程不需要停止;
    - 线程的run()方法完成;
    - 在对象上调用wait()方法（不是在线程上调用）;
    - 线程不能在对象上获得锁定，它正试图运行该对象的方法代码;、
    - 线程调度程序可以决定将当前运行状态移动到可运行状态，以便让另一个线程获得运行机会，而不需要任何理由

## 线程sleep()

- 线程休眠的目的是使线程让出CPU的最简单的做法之一，线程休眠时候，会将CPU资源交给其他线程，以便能轮换执行，当休眠一定时间后，线程会苏醒，进入准备状态等待执行
- 线程休眠不会释放对象的锁
- 两种方法调用是一样的，将当前thread,休眠掉

```java
    try {
        Thread.sleep(7*1000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }

    try {
        TimeUnit.SECONDS.sleep(7);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
```

## 线程优先级

- 调度器倾向于让优先级最高的线程先执行，但是并不是意味着低优先权的线程将得不到执行，也就是说优先权不会导致死锁
- 试图操纵线程优先级通常是一种错误
- 优先级是在run()方法中设定的，在构造器中设置它们不会有任何好处，因为Executor此时还没有开始执行任务
- Thread.MAX_PRIORITY, NORMAL_PRIORITY,MIN_PRIORITY

## 线程yield()

- 暗示cpu，工作差不多了，可以让别的线程使用cpu了
- 仅是一个暗示作用，没有任何机制可以保证它会被采纳
- 当调用yield（)时，也是在建议相同有限级的其它线程可以运行
- 调用Thread.yield(),当前线程从运行状态变为可运行状态

## 线程 join()

- **a线程的run中调用b.join()，a会被挂起，直到线程b结束才恢复（也就是b.isAlive（）为假）**
- 在一个线程上调用interrupt()时，将给该线程一个标志，表明该线程已经被中断，但是如果捕获了这个异常，则这个标志会被清除

## 后台线程

- **setDaemon(true)，必须在调用线程的start()方法之前调用**
- 后台线程是提供一种通用服务的线程，并且这种线程并不属于程序中不可或缺的一部分
- 当程序的所有非后台线程结束时，程序也就结束了，并且会杀死所有后台线程
- 只要存在任何非后台线程还在运行，程序就不会张终止
- **任何后台线程创建的线程都是后台线程**
- **当关闭最后一个非后台线程时，所有的后台线程都会被立即关闭，可能会导致后台线程的部分代码不会执行**，如果是非后台线程，则代码一定会执行

```java

class ADaemon implements Runnable {
    public void run() {
        try {
            print("Starting ADaemon");
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
          print ("Exiting via InterruptedException");
        } finally {
            print ("This should always run ?");
        }
    }


    public class DaemonsDontRunFinally {
        public static void main(String[] args) throws Exception {
            Thread t = new Thread(new ADaemon());
            t.setDaemon(true);
            t.start();
        }
    }
}

// output
// Starting ADaemon
// 其它的不会执行的


```

- 非后台的Executor是一种更好的方式，它可以控制所有任务可以同时被关闭


## 异常

- **由于线程的本质特性，不能捕获从线程中逃逸出来的异常**
- 使用Thread.UncaughtExceptionHandler
- UncaughtExceptionHandler主要分为3类：**Thread特有的，它所属线程组特有的，和所有Thread共有的DefaultUncaughtExceptionHandler**
- **还可以在Thread类中设置一个静态域，当线程不存在特有UncaughtExceptionHandler版本的，**
 **并且也没有线程组专有UncaughtExceptionHandler的时候，就会使用defaultUncaughtExceptionHandler**
 Thread.setDefaultUncaughtExceptionHandler(new MyUncaughtExceptionHandler());

```java
class MyUncaughtExceptionHandler implements
Thread.UncaughtExceptionHandler {
  public void uncaughtException(Thread t, Throwable e) {
    System.out.println("caught " + e);
  }
}
class HandlerThreadFactory implements ThreadFactory {
  public Thread newThread(Runnable r) {
    System.out.println(this + " creating new Thread");
    Thread t = new Thread(r);
    System.out.println("created " + t);
    t.setUncaughtExceptionHandler(
      new MyUncaughtExceptionHandler());
    System.out.println(
      "eh = " + t.getUncaughtExceptionHandler());
    return t;
  }
}
 ExecutorService exec = Executors.newCachedThreadPool(
      new HandlerThreadFactory());
```

## 使用Executor管理thread对象

- FixedThreadPool
- CachedThreadPool,通常会创建与所需相同数量的线程，然后在它回收旧线程时停止创建新线程
- SingleThreadExecutor，对于希望在同一个线程中连续运行的任何事物（长期存在的任务，比如长连接）来说，都是很有用的。
- 如果向SingleThreadExecutor中提交了多个任务，这些任务将排队，每个任务都会在下一个任务开始之前运行结束，
 所有的任务将使用相同的线程。因些它会序列化所有提交给它的任务，并会维护它自己的悬挂任务队列。
- SingleThreadExecutor上，由于是在同一线程，经常不需要在共享资源上作同步。


## ThreadFactory

- 每个ExecutorService的创建方法都被重载为接受一个ThreadFactory对象，而这个对象被用来创建对象

```java

public class DaemonThreadFactory implements ThreadFactory {
        public Thread newThread(Runnable r) {
              Thread t = new Thread();
              t.setDaemon(true);
              return t;
        }
}

ExecutorService exec = Executors.newCachedThreadPool(new DaemonThreadFactory());

```

## 从任务中返回值

- Runnable执行独立的任务，但不返回值，如果要返回值，使用Callable
- Callable必须使用EXecutorService.submit()方法调用它
- submit产生Future对象
- 可以用isDone()来检测Future是否完成
- 也可以直接调用get()，但是会阻塞

```java
class Task implements Callable<String> {
  private int id;
  public Task(int id) {
    this.id = id;
  }

  public String call(){
    return "result of Task" + id;
  }
}
ExecutorService exec = Executors.newCachedThreadPool();
List<Future<String>> list = new ArrayList<>();
for(int i = 0; i < 10; ++i) {
  list.add(exec.submit(new Task(i)));
}
```


## 解决共享资源兑争(互斥性)

- **对于并发工作，需要某种方式来防止两个任务访问相同的资源**，至少在关键时刻不能这样，**防止这种冲突的方法就是当资源被一个任务使用时，在其上加锁**
- **基本上所有的并发模式在解决线程冲突问题的时候，都是采用序列化访问共享资源的方案，这意味着在给定时刻只允许一个任务访问共享资源**
- java中，要控制对共享资源的访问，首先得把它包装进一个对象，然后把所有要访问这个资源的方法标记为synchronized
 使用并发时，必须将值设为private

## 同步与锁

### 同步

- 当提到同步时，应该清楚在什么上同步？也就是说，在哪个对象上同步？
- 不必同步类中所有的方法，**类可以同时拥有同步和非同步方法**，如果线程拥有同步和非同步方法，则非同步方法可以被多个线程自由访问而不受锁的限制。


### synchronized 与锁

- **使用并发时，必须将要保护的成员对象设置为private**
- **synchronized 只能同步方法和代码块**，不能同步变量和类
- **所有对象都自动含有单一的锁，在对象上调用任何 synchronized方法，对象会被加锁**
- **一个任务可以获得多个对象的锁**, 在一个对象的同步方法里面调用另外一个对象的同步方法，则获取了两个对象的同步锁。
- **一个任务也可以多次获得对象的锁**，比如在一个对象的synchronized方法里面调用这个对象的另一个synchronized汶法，那么每调用一次都会加锁一次，
 jvm会追踪加锁的次数，退出一个synchronized方法或代码块，加锁次数减1，当变为0时，释放对象的锁
- **对于某个对象来说，其所有非static synchronized方法共享一个锁**,如果某个任务处于一个对标记为synchronized的方法调用中，
 那么在这个线程从该方法返回之前，其它所有要调用类中任何标记为synchronized方法的线程都会被堵塞
- 每一个类也有一个锁，作为class对象的一部分，所以**synchronized static方法可以在类的范围内防止对static数据的并发访问**

```java
// 下面两个效果相同
class A {
    public static synchronized void staticMethod() {
         //
    }

    public static void staticMethod() {
        synchronized(A.class) {
            //...
        }
    }
}

```

### 共享资源

>> Brian同步原则：如果你正在写一个变量，它可能接下来被另一个线程读取，或者正在读取一个上一次已经被另一个线程写过的变量，那么你必须使用同步，并且，读写线程必须用相同的监视器锁同步

- **同步损害并发性，应该尽可能缩小同步范围**。
- **同步不但可以同步整个方法，还可以同步方法中一部分代码块**。
- **在使用同步代码块时候，应该指定在哪个对象上同步，也就是说要获取哪个对象的锁**

```java
// 下面两个效果相同
class A {
    public synchronized void someThing() {
         //
    }

    public  void someThing() {
        synchronized(this) {
            //...
        }
    }
}
```

- **每一个访问临界共享资源的方法都必须同步，否则它们就不会正常工作**
- **线程睡眠时，它所持的任何锁都不会释放**。
- 编写线程安全的类，需要时刻注意对多个线程竞争访问资源的逻辑和安全做出正确的判断，对“原子”操作做出分析，并保证原子操作期间别的线程无法访问竞争资源

### 显示的lock对象

- 显示的lock对象一般和try finally合在一起用，并且一定要在finally中unlock
- 如果失败可以抛出异常，也可以在finally中清理对象

``` java

public class A {
    private final Lock lock = new ReentrantLock();

    private int value = 0;

    public int next() {
        lock.lock();
        try {
            ++value;
            Thread.yield();
            ++value;
            return value;
        } finally {
            lock.unlock();
        }
    }
}

```

## 原子性与可见性

### 原子性

- **原子操作是不能被线程调度机制中断的操作，一旦操作完成，那么它一定可以在可能发生的“上下文切换“（切换到其它线程）之前执行完毕**
- **原子性可以应用于除了long与double之外的所有基本类型之上的读写操作**，可以保证它们会被当作不可分的操作来操作内存
- long,与double因为是64位，读取和写入被当作两个分离的32位操作来执行，从而可能在一个读取与写入之间发生上下文切换，处于不正确的状态
- **将long和double定义为volatile,就会获得简单的返回与赋值的原子性**
- **尝试用原子性来代替同步是一种不成熟的优化**，并且会给你招致大量的麻烦

### 可见性 与Volatile

- 在多处理器的系统中，**可见性的问题比原子性的问题更加严重**
- **一个任务做出的修改，即使在不中断的意义上讲是原子性的，对其它任务也有可能是不可见的**，有可能修改只是暂时性地存储在本地处理器的缓存中，
 没有刷新到主存中，造成可能对于其它线程是不可见的
- **没有同步机制，可视性无法确定**

### Volatile

- **volatile关键字，确保了应用中的可见性，如果将一个域声明为violatile,那么只要对这个域产生了写操作，那么所有的读操作都可以看到这个修改,**
 即使有本地缓存，情况也是如此，volatile域被立即写到主存中，而读取操作就是发生在主存的
- **在非volatile域上的原子操作不必刷新到主存中，因此其它读取该域的任务也不一定看到这个新值，没有保证可视性**
- **如果多个任务在同时访问这个域，那么这个域就应当是volatie的，否则，这个域就应当只能经由同步的来访问，也就是任何读写这个域的方法应当被synchronized保护**
- **如果一个域完全由synchronized方法和语句块来防护，那么这个域不必声明为volatile**
- **一个任务所作的任何写入操作对这个任务都是可见的,如果它只需要这个任务内部可见,那么它不必设置为volatile**
- **Volatile 但是本身却不能保证原子性与互斥性**
- **如果一个域的值依赖于它之前的值（例如一个递增计数器），volatile它就无法工作了**

```java

// volatile保证了可见性，但是由于自增操作不是原子性的，所有这个类不是线程安全的
public class SerialNumberGenerator {
    public static volatile int serialNumber = 0;

    public static int next() {
        return serialNumber++;
    }
}

```

- **如果某个域的值受到其它域的限制，比如Range的lower必须满足lower<= upper，volatile它就无法工作了**
- **使用volatile而不是synchronized的唯一安全的哪个情况是类中只有一个可变的域**
- **如果一个域可能会被多个任务同时访问，或者这些任务中至少有一个是写入任务，那么就应当将这个域设置为volatile的**

### 原子类

- 原子类，AtomicInteger, AtomicLong, AtomicReference等
- 只有在特殊的情况下，才使用原子类，**一般情况下依赖于锁，synchronized或显式的lock对象更安全**

```java

// 在多线程中使用没有同步的eventIncrement也不会出现问题
public class AtomicIntegerTest implements Runnable {
    private AtomicInteger i =  new AtomicInteger(0);

   public int getValue() {return i.get();}

   public void eventIncrement() { i.addAndGet(2);}

   public void run() {
       //....
   }
}
```

## 线程阻塞

- 调用同一个对象中非静态同步方法的线程将彼此阻塞。如果是不同对象，则每个线程有自己的对象的锁，线程间彼此互不干预。
- 调用同一个类中的静态同步方法的线程将彼此阻塞，它们都是锁定在相同的Class对象上。
- 静态同步方法和非静态同步方法将永远不会彼此阻塞，因为静态方法锁定在Class对象上，非静态方法锁定在该类的对象上。
- 对于同步代码块，要看清楚什么对象已经用于锁定（synchronized后面括号的内容）。在同一个对象上进行同步的线程将彼此阻塞，在不同对象上锁定的线程将永远不会彼此阻塞。



## 临界区

- 希望防止多个线程同时访问方法内部的部分代码而不是防止访问整个方法，通过这种方法分离出来的代码段被称为临界区
- 也就是在方法内部使用synchronized

## 在其它对象上同步

- synchronized必须给定一个在其上进行同步的对象，其中最合理的方式是，使用其方法正在被调用的当前对象，synchronized非静态方法就是这样
- 有时如果要在另一个对象上同步，则必须保证所有相关的作务都是在一个对象上同步
- synchronized(this)与synchronized当前对象内部的一个对象，两者不会因为对另一个方法的调用而互相阻塞

## ThreadLocal

- 防止任务在共享资源上产生冲突的第二次种方式，根除对变量的共享
- ThreadLocal,为使用相同变量的每个不同线程都创建不同的存储
























