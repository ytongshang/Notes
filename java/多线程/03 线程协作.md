# 线程协作

## wait notify notifyAll

- **调用对象的wait(),线程的执行会被挂起，对象的锁会被释放掉**，意味着另一个任务可以获得对象的锁，因而其它的线程
 可以调用对象的synchronized方法

- **通过调用notify(),notifyAll(),或者等到wait()时间结束后，被唤醒的线程首先要获得对象的锁，然后才可以继续执行**

- **wait,notify,notifyAll调用时必须获得对象的锁**，否则会抛出IllegalMonitorStateException

- **notify()只会唤醒对象等待唤醒线程中的一个**，具体哪个由jvm指定

```java
synchronized(x) {
    x.notifyAll();
}
```

- **一般情况下用一个检查感兴趣条件的while循环来包围wait,其中感兴趣的条件必须注意同步**
    - 一个原因是如果多个线程等待被唤醒，第一个被唤醒的线程可能改变这个条件
    - 在这个线程唤醒时，其它线程的某个改变让这个线程继续执行没有意义，应当继续wait下去
    - **多个线程出于不同的原因等待对象上的锁（必须使用notifyAll()）**,必须检查正确的原因

```java
// 要特别注意someCondition的同步
synchronized(x) {
    while (someCondition) {
        x.wait();
    }
}

synchronized(x) {
    while (true) {
        if (someCondition) {
            break;
        }
        x.wait();
    }
}

```

## 错失的信号量

- 假设T2对someCondition求值为true,这里线程切换到了T1,发送了notify信号，这时由于线程切换到了T1,T2不会被唤醒，从而错失了信号量

```java

//T1:
synchronized(x) {
    <setup condition for T2>
    x.notify();
}

//T2:
while(someCondition) {
    synchronized(x) {
        x.wait();
    }
}

```

- 正确的做法

```java
synchronized(x) {
    while(someConditon) {
        x.wait();
    }
}
```

## notify 与 notifyAll

- notify只会唤醒一个线程，如果有多个线程在等待，那么具体唤醒哪个由jvm指定
- notifyAll唤醒所有在这个对象上等待的线程，notify是对notifyAll的优化
- **如果有多个线程等待被唤醒，并且这些线程被唤醒的条件不同，那么必须用notifyAll**,否则的话，由于notify只唤醒一个，某个线程可能错过某个条件的信号量
- notifyAll只会唤醒在该对象调用wait方法的线程，如果monitor不同，其它monitor的不会被唤醒


## 生产者-消费者模型