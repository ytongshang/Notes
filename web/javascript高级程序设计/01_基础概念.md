# 基本概念


## 严格模式

```js
"use strict";

function doSomething(){
    "use strict";
    //函数体
}
```

## 数据类型

### Undefined

- 变量没有声明
- 变量声明了但是没有初始化

### null

- 表示一个空对象指针
- typeof null 返回object
- 定义变量如果用来保存对象，初始应当初始化为null

```js
alert(null == undefined);    //true
```

### Boolean

- undefined -> false
- Object, 任何对象 -> true,null -> false
- 任何非零字符串(包括无穷大) -> true, 0与NaN -> false
- 任何非空字符串 -> true,空字符串 -> false

### Number类型

- 浮点类型必须含有小数点，并且小数点后必须有一位数字
- **如果小数点后没有数字，那么直接认为是整型**
- **由于IEEE754的误差，一般不要进行浮点数的相等性比较**

#### 数值范围

- Number.MAX_VALUE, Number.MIN_VALUE
- Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY
- 只要一次计算返回了正的或负的Infinity,该值无法参与下一次计算
- **isFinite()返回是否在最大值与最小值之前**

```js
var result = Number.MAX_VALUE + Number.MAX_VALUE;
alert (isFinite(result));  // false
```

#### NaN

- Not a Number，表示一个本来要返回数值的操作数未返回数值的情况，这样不会抛错了
- 任何涉及NaN的操作（如NaN/10）都会返回NaN
- NaN和任何值都不相等，包括NaN本身

```js
alert(NaN == NaN);  // false
```

#### Number()

- Boolean, true->1, false -> 0
- null,返回0
- undefined 返回 NaN
- 字符串
    - 只包含数字，转换为十进制的数值，前导0会被忽略,"011"返回11
    - 有效的十六进制，转为对应的十进制
    - 空字符串转换为0
    - 包含上述格式之外字符的，转换为NaN
- 如果是对象，先使用valueOf()转为数字，如果返回是NaN,然后调用toString()转为字符串，然后再转换字符串为数字

#### parseInt()

- 忽略前面的空格，直到找到一个非空格字符
- 如是第一个字符不是数字字符或者负号，返回NaN
- 空字符串返回NaN
- 继续解析，直到遇到一个非字符数字

```js
parseInt("1234blue");   // 1234
parseInt("")  // NaN
parseInt("0xA");  // 10
parseInt("22.5")  // 22
parseInt("070");  // 56 八进制
```

- **parseInt(字符串，基数);避免因为进制引起的误解，任何时候都传入基数**

#### parseFloat()

- 只解析十进制数

### String

- text.length,返回字符数包括16位字符的数目，如果字符串中包含双字节字符，length可能不会精确返回字符串中的字符数目
- **不要用a.toString,使用String(a)**

## 操作符

### 布尔操作符

- 逻辑非操作符也可以用于将一个值转换为与其对应的布尔值
- **同时使用两个逻辑非操作符，实际上就会模拟 Boolean()转型函数的行为**。其中，第一个逻辑非操作会基于无论什么操作数返回一个布 尔值，而第二个逻辑非操作则对该布尔值求反，于是就得到了这个值真正对应的布尔值。当然，最终结 果与对这个值使用 Boolean()函数相同

### 逻辑与

- 逻辑与可以应用于任何类型的操作数，而不仅仅是布尔值。**在有一个操作数不是布尔值的情况下，逻辑与操作就不一定返回布尔值**
    - 如果第一个操作数是对象，则返回第二个操作数;
    - 如果第二个操作数是对象，则只有在第一个操作数的求值结果为 true 的情况下才会返回该对象;
    - 如果两个操作数都是对象，则返回第二个操作数;
    - 如果有一个操作数是 null，则返回 null;
    - 如果有一个操作数是 NaN，则返回 NaN;
    - 如果有一个操作数是 undefined，则返回 undefined

### 逻辑或

- 与逻辑与操作相似，如果有一个操作数不是布尔值，逻辑或也不一定返回布尔值
    - 如果第一个操作数是对象，则返回第一个操作数;
    - 如果第一个操作数的求值结果为 false，则返回第二个操作数;
    - 如果两个操作数都是对象，则返回第一个操作数;
    - 如果两个操作数都是 null，则返回 null;
    - 如果两个操作数都是 NaN，则返回 NaN;
    - 如果两个操作数都是 undefined，则返回 undefined

```js
// 避免myObject为空或者undefined
var myObject = maybeNull || {};
```

### 乘性操作符

- 如果某个操作符不是数值，会通过Number()进行转换

#### 乘法

- 如果操作数都是数值，执行常规的乘法计算，即两个正数或两个负数相乘的结果还是正数，而如果只有一个操作数有符号，那么结果就是负 数。如果乘积超过了 ECMAScript 数值的表示范围，则返回 Infinity 或-Infinity
- 如果有一个操作数是 NaN，则结果是 NaN;
- **如果是 Infinity 与 0 相乘，则结果是 NaN**
- 如果是 Infinity 与非 0 数值相乘，则结果是 Infinity 或-Infinity，取决于有符号操作数的符号;
- 如果是 Infinity 与 Infinity 相乘，则结果是 Infinity;

#### 除法

- 如果操作数都是数值，执行常规的除法计算，即两个正数或两个负数相除的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。如果商超过了 ECMAScript 数值的表示范围，则返回 Infinity 或-Infinity
- 如果有一个操作数是 NaN，则结果是 NaN;
- 如果是 Infinity 被 Infinity 除，则结果是 NaN;
- **如果是零被零除，则结果是 NaN**
- **如果是非零的有限数被零除，则结果是 Infinity 或-Infinity，取决于有符号操作数的符号**
- 如果是 Infinity 被任何非零数值除，则结果是 Infinity 或-Infinity，取决于有符号操作数的符号

#### 求模

- 如果操作数都是数值，执行常规的除法计算，返回除得的余数;
- 如果被除数是无穷大值而除数是有限大的数值，则结果是 NaN;
- 如果被除数是有限大的数值而除数是零，则结果是 NaN;
- 如果是 Infinity 被 Infinity 除，则结果是 NaN;
- 如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数;
- 如果被除数是零，则结果是零;
- 如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值，然后再应用上面的规则

### 加性操作符

#### 加法

- 如果有一个操作数是 NaN，则结果是 NaN;
- 如果是 Infinity 加 Infinity，则结果是 Infinity;
- 如果是-Infinity 加-Infinity，则结果是-Infinity;
- 如果是 Infinity 加-Infinity，则结果是 NaN;
- 如果是+0 加+0，则结果是+0;
- 如果是-0 加-0，则结果是-0;
- 如果是+0 加-0，则结果是+0。
- 不过，如果有一个操作数是字符串，那么就要应用如下规则:
    - 如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来;
    - 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来。
- 如果有一个操作数是对象、数值或布尔值，则调用它们的 toString()方法取得相应的字符串值，然后再应用前面关于字符串的规则。对于 undefined 和 null，则分别调用 String()函数并取得字符 串"undefined"和"null"

```js
// 常见错误
var num1 = 5;
var num2 = 10;
var message = "The sum of 5 and 10 is " + num1 + num2;
alert(message); // "The sum of 5 and 10 is 510"
message = "The sum of 5 and 10 is " + (num1 + num2);
```

#### 减法

- 如果两个操作符都是数值，则执行常规的算术减法操作并返回结果;
- 如果有一个操作数是 NaN，则结果是 NaN;
- 如果是 Infinity 减 Infinity，则结果是 NaN;
- 如果是-Infinity 减-Infinity，则结果是 NaN;
- 如果是 Infinity 减-Infinity，则结果是 Infinity;
- 如果是-Infinity 减 Infinity，则结果是-Infinity;
- 如果是+0 减+0，则结果是+0;
- 如果是+0 减-0，则结果是-0;
- 如果是-0 减-0，则结果是+0;
- 如果有一个操作数是字符串、布尔值、null 或 undefined，则先在后台调用 Number()函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是 NaN，则减法的结果就是 NaN;
- 如果有一个操作数是对象，则调用对象的 valueOf()方法以取得表示该对象的数值。如果得到的值是 NaN，则减法的结果就是 NaN。如果对象没有 valueOf()方法，则调用其 toString()方法并将得到的字符串转换为数值

### 关系操作符

- 如果两个操作数都是数值，则执行数值比较。
- 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。
- 如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。
- 如果一个操作数是对象，则调用这个对象的 valueOf()方法，用得到的结果按照前面的规则执行比较。如果对象没有 valueOf()方法，则调用 toString()方法，并用得到的结果根据前面的规则执行比较。
- 如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较

```js
var result = "23" < "3";    //true
var result = "23" < 3;      //false  会转化为数字
```

- **任何操作符与NaN进行比较，结果都是false**

```js
"a" < 3;  // NaN < 3 false
NaN < 3;  // false
NaN >= 3; // false
```

### 相等操作符

- 相等和不相等，先转换成相似的类型再进行比较
- 全等和不全等，仅比较而不转换

#### 相等

- 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false 转换为0，而true 转换为 1
- 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值;
- 如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()方法，用得到的基本类型值按照前面的规则进行比较;

- 这两个操作符在进行比较时则要遵循下列规则
    - null 和 undefined 是相等的。
    - 要比较相等性之前，不能将 null 和 undefined 转换成其他任何值。
    - 如果有一个操作数是 NaN，则相等操作符返回 false，而不相等操作符返回 true
    - 即使两个操作数都是 NaN，相等操作符也返回 false;因为按照规则，NaN 不等于 NaN。
    - 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true;否则，返回 false

```js
null == undefined  // true
"NaN" == NaN       // false, 有数值，字符串转为数字
5 == NaN           // false
NaN == NaN         // false
NaN != NaN         // true
false == 0         // true
true == 1          // true
true == 2          // false
undefined == 0     //false
null == 0          // false
"5" == 5           // true
```

#### 全等与不全等

- 不进行类型转换

```js
null == undefined  // true
null === undefined // false
```

### 逗号

- 用于赋值时，返回表达式中的最后一项

```js
var num = (5,1,4,8, 0);  // num的值为0
```

## 语句

### for in

- **通过 for-in 循环输出的属性名的顺序是不可预测的**
- 如果表示要迭代的对象的变量值为 null 或 undefined，for-in 语句会抛出错误。 ECMAScript 5 更正了这一行为;对这种情况不再抛出错误，而只是不执行循环体
- **为了保证最大限度的兼容性，建议在使用 for-in 循环之前，先检测确认该对象的值不是 null 或 undefined**

```js
for (var propName in window) {
     document.write(propName);
}
```

### with 语句

- with 语句的作用是将代码的作用域设置到一个特定的对象中
- 一般不建议使用with语句

```js
var qs = location.search.substring(1);
var hostName = location.hostname;
var url = location.href;

with(location){
    var qs = search.substring(1);
    var hostName = hostname;
    var url = href;
}
```

### switch语句

- switch语句中可以使用任何数据类型
- 每个case的值不一定是常量，可以是变量，甚至是表达式
- **switch 语句在比较值时使用的是全等操作符，因此不会发生类型转换**

```js
switch ("hello world") {
    case "hello" + " world":
        alert("Greeting was found.");
        break;
    case "goodbye":
        alert("Closing was found.");
        break;
    default:
        alert("Unexpected message was found.");

var num = 25;
switch (true) {
    case num < 0:
        alert("Less than 0.");
        break;
    case num >= 0 && num <= 10:
        alert("Between 0 and 10.");
        break;
    case num > 10 && num <= 20:
        alert("Between 10 and 20.");
        break;
    default:
        alert("More than 20.");
}
```

## 函数

- 没有函数签名的概念，真正调用时是使用arguments进行调用
- 参数类型与数量实际可以与函数定义不同，**利用这一特性来实现“函数的重载”**
- **没有传递值的命名参数将自动被赋予 undefined 值**
- **所有参数传递的都是值，不可能通过引用传递参数**
- **js函数不能像传统意义上那样实现重载,如果在js中定义了两个名字相同的函数，则该名字只属于后定义的函数**

```js
// 间接实现函数的重载
function doAdd() {
    if (arguments.length == 1) {
        alert (arguments[0] + 10);
    } else if (arguments.length == 2) {
        alert(arguments[0] + arguments[1])
    }
}
```

## 基本类型与引用类型

- Undefined, Null Boolean, Number, String，基本类型，按值访问，因为可以操作保存在变量中的值
- 引用类型，不能操作对象的内存空间，操作对象的引用
- 函数传递按值传递

```js
function setName(obj) {
    obj.name = "Nicholas";
    obj = new Object();
    obj.name = "Greg";
}
var person = new Object();
setName(person);
alert(person.name);    //"Nicholas"
```

## 类型检查

- typeof
- 对于对象，我们并不仅仅想知道某个值是对象，而是想知道它是什么类型的对象，使用instanceof操作符
- instanceof在基本类型是使用，始终返回false

```js
// 根据原型链来识别
result = variable instanceof constructor
```

## 执行环境

- 全局执行环境是最外围的一个执行环境
- 在 Web 浏览器中，全局执行环境被认为是 window 对象，因此所有全局变量和函数都是作为 window 对象的属性和方法创建的
- 每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。 而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境

### 没有块级作用域

- **JavaScript没有块级作用域经常会导致理解上的困惑**。在其他类 C 的语言中，由花括号封闭的代码 块都有自己的作用域(如果用ECMAScript 的话来讲，就是它们自己的执行环境)，因而支持根据条件来定义变量

```js
if (true) {
    var color = "blue";
}
alert(color);    //"blue"
```

#### 注意for语句

- 对于 JavaScript 来说，**由for语句创建的变量i即使在fo 循环执行结束后，也依旧会存在于循环外部的执行环境中**

```js
for (var i=0; i < 10; i++){
    doSomething(i);
}
alert(i);      //10
```

- 在编写 JavaScript 代码的过程中，不声明而直接初始化变量是一个常见的错误做 法，因为这样可能会导致意外

## 垃圾回收

- 全局变量，不再使用时，将其置为null来释放其引用

```js
function createPerson(name){
    var localPerson = new Object();
    localPerson.name = name;
 }
var globalPerson = createPerson("Nicholas"); // 手工解除 globalPerson 的引用
globalPerson = null;
```

## 引用对象

- 在使用对象字面量语法时，属性名也可以使用字符串
- 使用字面常量创建对象时，不会调用其构造函数

```js
var person = new Object();
person.name = "Nicholas";
person.age = 29;

var person = {
    name : "Nicholas",
    age : 29
};

var person = {
    "name" : "Nicholas",
    "age" : 29,
    5 : true
};
```

- **最好的做法是对那些必需值使用命名参数，而使用对象字面量来封装多个可选参数**

```js
function displayInfo(args) {
    var output = "";
    if (typeof args.name == "string"){
        output += "Name: " + args.name + "\n";
    }
    if (typeof args.age == "number") {
        output += "Age: " + args.age + "\n";
    }
    alert(output);
}

displayInfo({
    name: "Nicholas",
    age: 29
});

displayInfo({
    name: "Greg"
});
```

- 运算符与方括号运算符来访问对象，**方括号时，使用字符串**
- 方括号语法的主要优点是可以通过变量来访问属性

```js
alert(person["name"]); //"Nicholas"
alert(person.name); //"Nicholas"

// 通过变量来访问属性
var propertyName = "name";
alert(person[propertyName]); //"Nicholas"
```

## Array

- **数组每一项可以存任何类型对象,数组可以动态增长长度**
- 使用字面常量创建Array时，不会调用其构造函数

```js
var colors = new Array();
var colors = new Array(20);
var colors = new Array("red", "blue", "green");
var names = [];  // 创建一个空数组
var colors = ["red", "blue", "green"]; // 创建一个包含 3 个字符串的数组
```

```js
var colors = ["red", "blue", "green"]; // 定义一个字符串数组
alert(colors[0]);     // 显示第一项
colors[2] = "black";  // 修改第三项
colors[3] = "brown";  // 新增第四项
```

### length

- **js中数组的length属性不是只读的，通过设置这个属性，可以从数组的末尾移除项或向数组中添加新项**

```js
var colors = ["red", "blue", "green"]; // 创建一个包含 3 个字符串的数组
colors.length = 2;
alert(colors[2]); //undefined

var colors = ["red", "blue", "green"]; // 创建一个包含 3 个字符串的数组
colors.length = 4;
alert(colors[3]);
```

- **利用length属性也可以方便地在数组末尾添加新项**

```js
var colors = ["red", "blue", "green"];
colors[colors.length] = "black";
colors[colors.length] = "brown";

var colors = ["red", "blue", "green"]; // 创建一个包含 3 个字符串的数组
colors[99] = "black"; // (在位置 99)添加一种颜色
alert(colors.length); // 100
```

### 判断是否是数组

- 判断是否是数组, 对于一个网页，或者一个全局作用域，可以用instanceof,ECMAScript5使用Array.isArray()来判断

```js
if (value instanceof Array) {
    //
}

if (Array.isArray(value)){
    //对数组执行某些操作
}
```

### toString

- Array的toString默认调用每一项的toString,而toLocaleString默认调用每一项的toLocaleString
- join()方 法只接收一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串

```js
var colors = ["red", "green", "blue"];
alert(colors.join(","));       //red,green,blue
alert(colors.join("||"));      //red||green||blue
```

- **如果数组中的某一项的值是 null 或者 undefined，那么该值在 join()、 toLocaleString()、toString()和 valueOf()方法返回的结果中以空字符串表示**

### 栈方法

- push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度
- pop()方法则从数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项

```js
var colors = new Array();
var count = colors.push("red", "green");
alert(count); //2

count = colors.push("black");
alert(count);     //3

var item = colors.pop();
alert(item);      //"black"
alert(colors.length);   //2
```

### 队列方法

- 队列在列表的末端添加项，从列表的前端移除项
- push()是向数组末端添加项的方法
- shift()，它能够移除数组中的第一个项并返回该项，同时将数组长度减 1

```js
var colors = new Array();
var count = colors.push("red", "green");
alert(count); //2

count = colors.push("black");
alert(count);     //3

var item = colors.shift();
alert(item); //"red"
alert(colors.length); //2
```

- unshift与shift相反，它能在数组前端添加任意个项并返回新数组的长度
- **unshift("A", "B"),则数组是["A"，"B"], 而不是["B"，"A"]**
- 同时使用 unshift()和 pop()方法，可以 12 从相反的方向来模拟队列，即在数组的前端添加项，从数组末端移除项

```js
var colors = new Array(); //创建一个数组
var count = colors.unshift("red", "green"); //推入两项
alert(count); //2
console.log(colors);   // ["red", "green"]

count = colors.unshift("black");
alert(count);   //3

var item = colors.pop();
alert(item);    //"green"
alert(colors.length); //2
```

### 重排序

- reverse()和 sort()

```js
var values = [1, 2, 3, 4, 5]; 
values.reverse();
alert(values); //5,4,3,2,1
```

- 默认情况下sort升序排序，为了实现排序，sort()方法会调用每个数组项的 toString()转型方法，然后比较得到的字符串，以确定如何排序

```js
var values = [0, 1, 5, 10, 15];
values.sort();
alert(values);     //0,1,10,15,5
```

- sort()方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面
- 比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等 则返回 0，如果第一个参数应该位于第二个之后则返回一个正数

```js
function compare(value1, value2) {
    if (value1 < value2) {
        return -1;
    } else if (value1 > value2) {
        return 1;
    } else {
        return 0;
    }
}
```

- 对于数值类型或者其 valueOf()方法会返回数值类型的对象类型，可以使用一个更简单的比较函数。这个函数只要用第二个值减第一个值即可

```js
function compare(value1, value2){
    return value2 - value1;
}
```

### concat()

- concat()方法可以基于当前数组中的所有项创建一个新数组。
    - 这个方法会先创建当前数组一个副本
    - 然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组
- 在没有给 concat()方法传递参数的情况下，它只是 复制当前数组并返回副本。
- 如果传递给 concat()方法的是一或多个数组，则该方法会将这些数组中的每一项都添加到结果数组中。
- 如果传递的值不是数组，这些值就会被简单地添加到结果数组的末尾

```js
var colors = ["red", "green", "blue"];
var colors2 = colors.concat("yellow", ["black", "brown"]);
alert(colors);     //red,green,blue
alert(colors2);    //red,green,blue,yellow,black,brown
```

### slice()

- 基于当前数组中的一或多个项创建一个新数组，**与golang中不同，修改数组不会影响原数组**
- slice()方法可以 接受一或两个参数，即要返回项的起始和结束位置
- 在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项
- 如果有两个参数，该方法返回起始和结束位置之间的项,但不包括结束位置的项

```js
var colors = ["red", "green", "blue", "yellow", "purple"];
var colors2 = colors.slice(1);
var colors3 = colors.slice(1,4);
alert(colors2);   //green,blue,yellow,purple
alert(colors3);   //green,blue,yellow
```

- **如果 slice()方法的参数中有一个负数，则用数组长度加上该数来确定相应的位置**。例如，在一个包含 5 项的数组上调用 slice(-2,-1)与调用 slice(3,4)得到的 结果相同。如果结束位置小于起始位置，则返回空数组

### splice()方法

- splice(index,howmany,item1,.....,itemX) 方法向/从数组中添加/删除项目，然后返回被删除的项目
    - index 必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。
    - howmany 必需。要删除的项目数量。如果设置为 0，则不会删除项目。
    - item1, ..., itemX 可选。向数组添加的新项目

```js
var colors = ["red", "green", "blue"];
var removed = colors.splice(0,1);
alert(colors); // green,blue
alert(removed); // red，返回的数组中只包含一项

removed = colors.splice(1, 0, "yellow", "orange");
alert(colors); // green,yellow,orange,blue
alert(removed); // 返回的是一个空数组

removed = colors.splice(1, 1, "red", "purple");
alert(colors); // green,red,purple,orange,blue
alert(removed); // yellow，返回的数组中只包含一项
```

### 迭代方法

- 迭代方法，所有迭代方法都不会修改数组中包含的值
    - every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true。
    - filter()：对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。
    - forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。
    - map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。
    - some()：对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true。

### 归并方法

- reduce()和 reduceRight()，这两个方法都会迭代数组的所有项，然后构建一个最终返回的值
- reduce()方法从数组的第一项开始，逐个遍历到最后。
- reduceRight()则从数组的最后一项开始，向前遍历到第一项
- 这两个方法都接收两个参数，一个在每一项上调用的函数和（可选的）作为归并基础的初始值。
- 传给 reduce()和 reduceRight()的函数接收 4 个参数：
    - 前一个值、当前值、项的索引和数组对象。
    - 这个函数返回的任何值都会作为第一个参数自动传给下一项。
    - 第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项

```js
var values = [1,2,3,4,5];
var sum = values.reduce(function(prev, cur, index, array){
 return prev + cur;
});
alert(sum); //15
```