# 高级类型

## 交叉类型

-   交叉类型是将多个类型合并为一个类型

```ts
function extend<T, U>(first: T, second: U): T & U {
    let result = <T & U>{};
    for (let id in first) {
        (<any>result)[id] = (<any>first)[id];
    }
    for (let id in second) {
        if (!result.hasOwnProperty(id)) {
            (<any>result)[id] = (<any>second)[id];
        }
    }
    return result;
}

class Person {
    constructor(public name: string) {}
}
interface Loggable {
    log(): void;
}
class ConsoleLogger implements Loggable {
    log() {
        // ...
    }
}
var jim = extend(new Person('Jim'), new ConsoleLogger());
var n = jim.name;
jim.log();
```

## 联合类型

-   联合类型表示一个值可以是几种类型之一
-   如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员

```ts
interface Bird {
    fly();
    layEggs();
}

interface Fish {
    swim();
    layEggs();
}

function getSmallPet(): Fish | Bird {
    // ...
}

let pet = getSmallPet();
pet.layEggs(); // okay
pet.swim(); // errors
```

## 类型区分

### 自定义类型区分

```ts
interface Bird {
    fly();
    layEggs();
}

interface Fish {
    swim();
    layEggs();
}

// parameterName is Type形式，parameterName必须是来自于当前函数签名里的一个参数名
function isFish(pet: Fish | Bird): pet is Fish {
    return (<Fish>pet).swim !== undefined;
}
```

### typeof

-   ** typeof 类型守卫只有两种形式能被识别：typeof v === "typename"和 typeof v !== "typename"**
-   **"typename"必须是"number"，"string"，"boolean"或"symbol"。 但是 TypeScript 并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型守卫**
