# 泛型

- 使用泛型的最初原因在于：要想使类或方法具有广泛的表达力，能过解耦类或方法与所使用的类型之间的约束

## 泛型方法

- 是否拥有泛型方法，与其所在的类是否是泛型完全没有关系
- 泛型方法优先于泛型类
- 如果类的static方法要使用泛型，因为static方法不能访问类的泛型参数，所以必须使用泛型方法
- 使用泛型类时，必须在创建对象时指定类型参数，而使用泛型方法通常不必指定参数。
- 泛型方法可以显示的指明参数类型，要显式的指明类型，必须在点操作符和方法名之间插入尖括号，然后把类类型置于尖括号内，
 如果是在定义该方法的类的内部，必须在点操作符之前使用this关键字，如果是使用static方法，则必须在点操作符之前加上类名

```java
 public class New {
     public static <K,V> Map<K,V> map() {
         return new HashMap<K,V>();
     }

     f(New.<Person,List<Pet>>map());
 }
```

## 擦除

### 擦除基本

- 对于拥有不同泛型参数的泛型类的对象来说，它们的类型是一样的

```java
Class c1 = new ArrayList<String>().getClass();
Class c2 = new ArrayList<Integer>().getClass();

c1 == c2; // true
```

- 在泛型代码内部，**无法获取任何有关类型参数类型的信息**，
 也就是说**无法显式的引用运行时类型的操作，比如转型,instanceof操作和new表达式**

- **java的泛型是使用擦除来实现的**，这意味着在**使用泛型时，任何具体的类型信息都被擦除了，你唯一知道的是你在使用一个对象**，
 因而List<Person>与List<Integer>在运行时的类型是一样,它们都被擦除成了原生类型List

### 泛型边界

- 如果对泛型的参数有限制,必须对泛型参数的边界加以限制,主要有**extends,super 和 ?**



- 如果我们在泛型中如果要使用泛型参数的具体方法，则必须给泛型参数设定边界，以此告诉编译器只能接受遵询这个边界的类型。
- 泛型不能用于显示地引用运行时类型的操作之中，编写泛型代码时，必须时刻提醒自己，你只是看起好像拥有有类参数的类型信息而已，必须时刻提醒自己，它只是一个Object
- 对于泛型创建数组时，使用Array.newInstance()是推荐的方法
- 因为擦除可以移除类型信息，所以在运时时的问题就是边界，即对象进入和离开方法的地点，对传递进来的值进行客外的编译期检查 并插入对传递出去的值的转型
