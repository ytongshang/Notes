# 泛型

- 使用泛型的最初原因在于：要想使类或方法具有广泛的表达力，能过解耦类或方法与所使用的类型之间的约束
- 只有当你希望使用的类型参数比某个具体类型更加泛化时，也就是说，当你希望代码能够跨多个类工作时，才使用泛型

## 泛型方法

- 是否拥有泛型方法，与其所在的类是否是泛型完全没有关系
- 泛型方法优先于泛型类
- 如果类的static方法要使用泛型，因为static方法不能访问类的泛型参数，所以必须使用泛型方法
- 使用泛型类时，必须在创建对象时指定类型参数，而使用泛型方法通常不必指定参数。
- 泛型方法可以显示的指明参数类型，要显式的指明类型，必须在点操作符和方法名之间插入尖括号，然后把类类型置于尖括号内，
 如果是在定义该方法的类的内部，必须在点操作符之前使用this关键字，如果是使用static方法，则必须在点操作符之前加上类名

```java
 public class New {
     public static <K,V> Map<K,V> map() {
         return new HashMap<K,V>();
     }

     f(New.<Person,List<Pet>>map());
 }
```

## 擦除

### 擦除基本

- **java的泛型是使用擦除来实现的**，这意味着在**使用泛型时，任何具体的类型信息都被擦除了，你唯一知道的是你在使用一个对象**，
 因而List<Person>与List<Integer>在运行时的类型是一样,它们都被擦除成了原生类型List

```java

Class c1 = new ArrayList<String>().getClass();
Class c2 = new ArrayList<Integer>().getClass();
c1 == c2; // true

```

- 泛型参数被当作第二类型处理，即不能在某些重要的上下文环境中使用的类型，**泛型只有在静态类型检查期间才出现**
 **在此以后，程序中所有的泛型类型都将被擦除，替换为它们的第一个非泛型上界，如果没有指定边界，它将被擦除成Object**
- 编写泛型代码时，必须时刻提醒自己，**你只是看起来好像拥有有关参数的类型信息而已**，但实际上它只是一个Object
- 在泛型代码内部，**无法获取任何有关类型参数类型的信息**，
 也就是说**无法显式的引用运行时类型的操作，比如转型,instanceof操作和new表达式**

### 擦除的补偿

- 泛型由理擦除不能进行instanceOf等操作，但是可以能过传入泛型的class对象来进行类型判断,主要是**使用Class.isInstance方法**

```java
public class ClassTypeCapture<T> {
    private Class<T> kind;

    public ClassTypeCapture(Class<T> kind) {
        this.kind = kind;
    }

    public boolean f (Object arg) {
        return kind.isInstance(arg);
    }
}
```

- 泛型中创建泛型参数类对象，方法是使用工厂模式，不过一种方法是使用Class对象的newInstance()方法，但是这种有限制，对象必须有public的无参构造函数，
 另外一种是使且显示的工厂模式

 ```java

 class ClassAsFactory <T> {
     private T x;

     public ClassAsFactory(Class<T> kind) {
         try {
             x = kind.newInstance();
         } catch (Exception e) {
             throw new RuntimeException(e);
         }
     }
 }
 ```

 ```java

interface Factory<T> {
    T create();
}

class Foo<T> {
    private T x;

    public <F extends Factory<T>> Foo(F factory) {
        x = factory.create();
    }
}

 ```

- 一般情况下，不能创建泛型的数组，一般的解决办法是在任何纯净度为创建泛型数组的地方使用ArrayList
  另外一种方法是创建一个泛型边界的数组，**并且在类的内部也保存的是边界的数组，然后在使用数组元素的时候，添加转型**
  **千万注意不要在类的内部保存T[]的数组**


```java
public class GenericArray<T> {
    private Object[] array;

    public GenericArray(int size) {
        array = new Object[size];
    }

    public void put(int index, T item) {
        array[index] = item;
    }

    @SuppressWarnings("unchecked")
    public T get(int index) {
        return (T)array[index];
    }

    @SuppressWarnings("unchecked")
    public T[] rep() {
        return (T[]) array;
    }
}

```

## 泛型边界

- 如果对泛型的参数有限制,必须对泛型参数的边界加以限制,主要有**extends,super 和 ?**

### extends

- **泛型参数可以有多个边界**，但是class边界只能有一个，其它只能是interface,并且在使用extends的时候，必须先是class的然后才是interface的

```java

interface HasColor {}

interface Dimension{}

class View {}

class ColoredDimension<T extends View & HasColor & Dimension> {}

// 下面这种是错误的，必须先class,然后interface
//class ColoredDimension<T extends HasColor & HasColorView & Dimension> {}

```

- 泛型中所有的动作都发生在边界处，对传递进来的值进行额外的编译期检查，并插入对传递出去的值的额外转型
- 泛型是使用擦除来实现的，所有泛型之间不存在转型

```java
// compile error
// List<Fruit> fruits = new ArrayList<Apple>();
```

### 通配符

- **通配符“?”实际上表示某种，只是不知道它的确切类型**，比如List<? extends Fruit> 表示某种Fruit/Fruit子类的列表，
 但是并不意味着它可以持有任何的Fruit
- 当我们指定类型是List<? extends Fruit> 的时候，list的add的方法的参数
 就变成了? extends Fruit,它不知道是哪种类型，所以也就不支持任何的Fruit类型

```java
// 可以向上转型，但是下面任何一种添加都是错误的
List<? extends Fruit> flist = new ArrayList<Apple>();

// compile error
//flist.add(new Apple());
//flist.add(new Fruit());
//flist.add(new Object());

// 添加null是可以的，但是没有意义
flist.add(null);

// 但是可以确保它的每一个元素至少是一个Fruit
Fruit f = flist.get(0);
```

- List 实际上表示持有任何类型的原生List,相当于List<Object>
 而List<?> 表示具有某种特定类型的非原生List,只是我们不知道那种类型是什么

### super

- 表示是某个类型的某个父类，但是也不确定到底是哪个父类

```java
<? super MyClass>
<? super T>
// compile error
<T super MyClass>
```

## 泛型常见的问题

### 基本类型

- **不能将基本类型作为泛型的参数**
- 基本类型的包装类的泛型由于自动包装和解包是可以操作基本类型
- 由于操作基本类型会自动包装和解包，对性能有一定的影响，**如果性能成了问题，必须使用专门适配基本类型的容器版本**
- 自动包装和解包也不是在所有的地方都会发生

```java
class FArray {
    public static <T> T[] fill(T[] a, Generator<T> gen) {
        for (int i =0; i < a.length; ++i) {
            a[i] = gen.next();
        }
        return a;
    }

    // compile error
    //int[] b =  FArray.fill(new int[7], new RandomGenerator());
}
```

### 实现参数化接口

- 一个类不能实现同一个泛型接口的两种变体

```java

interface Payable<T> {}

class Employee implements Payable<Employee> {}

// compile error
// class Hourly extends Employee implements Payable<Hourly> {}

```

### 转型警告

- 在泛型中会经常出现转型警告，可以使用@SuppressWarnings,**但是应当在尽可能小的范围使用它**，
 **能语句的绝不函数，能函数的绝不类**
- **泛型转型，使用cast**

```java
public class ClassCast {
    @SuppressWarnings("unchecked")
    public void  f (String[] args) throws Exception {
        ObjectInputStream in = new ObjectInputStream(new FileInputStream(args[0]));

       // compile error
        List<Widget> lw = List<Widget>.class.cast(in.readObject());

        List<Widget> lw2 = List.class.cast(in.readObject())
    }
}

```

### 重载

- 仅仅泛型参数不同的两个相同签名的函数在java中不能编译通过的,
 其主要原因是，**由于擦除的原因，两者将产生相同的签名**

```java
public class UserList<W, V> {

    // compile error
    void f (List<W> wlist) {}

    void f(List<V> vlist) {}
}

```

### 基类劫持了接口

```java
public class ComparablePet implements Comparable<ComparablePet> {
    public int compareTo(ComparablePet o ) { return 0;}
}

public class Cat extends ComparablePet implements Comparable<Cat> {
    // compile error,基类指定了是ComparablePet,不能再一次变为Cat
   // pulbic int compareTo(Cat o) {return 0;}
}

class Hamster extends  ComparablePet implements Comparable<ComparablePet> {
     public int compareTo(ComparablePet o ) { return 0;}
}

class Hamster extends  ComparablePet {
     public int compareTo(ComparablePet o ) { return 0;}
}
```

## 代码注意

- 泛型方法优于泛型类

- 在泛型中创建数组，可以建立一个Object的数组，然后进行强转，
 但是使用Array.newInstance()是推荐的方式

 ```java
 public class ArrayMaker<T> {
     private Class<T> kind;

     public ArrayMaker(Class<T> kind) {
         this.kind = kind;
     }

     @SuppressWarnings("unchecked")
     T[] create(int size) {
         return (T[])Array.newInstance(kind, size);
     }
 }
 ```