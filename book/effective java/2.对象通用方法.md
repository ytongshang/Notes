# 对象通用的方法

## equals方法

### 重写的原因

- 有时类除了有对象相等的概念之外，还有**逻辑相等**的概念，这时就应当重写equals()对象通用的方法
- 如果想让对象作为map的key 或者存放到set中，并且让它们以一种正常的方式工作，那么也应当重写equals方法
- 超类已经覆盖了equals,**那么从超类继承过来的行为对子类也是合适的**，但是正是因为如此，如果子类新增了一些关键的变量，也必须要重写equals()对象通用的方法

### 重写的原则

- 自反性，x.equals(x)，永远为true
- 对称性，x.equals(y) = y.equals(x)
- 传递性，x.equals(y) = true, y.equals(z) = true,那么x.equals(z) = true
- 一致性，对于非null的x,y,只要在equals()方法中所用到的对象信息没有发生变化，那么x.equals(y)的结果就应当不变
 也就是说equals的判断中所用的值域不要使用不可靠的资源
- 非空性，对于非null的x,x.equals(null)一定为false
- 一般情况下，自反性和非空性都比较好满足，所以比较重要的就是对称，传递和一致性

### 注意点

- 如果 **重写了equals,那么必须重写hashCode()** 方法
- 不要让重写的equals方法太过智能，比如file和指向同一文件的link file是不相等的
- 重写时，一定要**注意不能将方法声明中的Object对象替换成其它的对象**

### 重写步骤

- 首先使用==进行对象的相等性判断
- 然后使用instanceOf操作符检查"参数类型"是否正确，因为null instanceOf Type 肯定会返回为false,所以如果采用了instanceOf,不用判断null,
 **并且一般不采用getClassName()进行字符串比较**，否则在父类与子类之间的比较有可能出现问题
- 把参数转换成正确的类型
- 对于该类中的每个关键域，比较参数中的域与该对象对应的域是否相等，**如果域可能为null,那么在比较域与域是否相等时，要注意null的判断**

```java
public class Test {
    public int count;
    public A a;

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (!(o instanceOf Test) {
            return false;
        }
        Test other = (Test)o;
        return count == other.count && (a == other.a || (a != null && a.equals(other.a));
    }

    public int hashCode() {
        //....
    }
}

```

## hashCode()方法

### hashCode()方法原则

- 只要一个对象equals方法比较操作所用的对象没有变，那么hashCode()就应当不变，
 也就是说hashCode()的计算应当并且只应当参考与equals中比较用到的域
- **如果两个对象equals()返回为true,那么这两个对象返回的hashCode()也应当相等**
- 如果两个对象equals()返回为false,但是**它们的hashCode()可能是相等**的，但是为了提高散列表的性能，
 一般情况下**如果两个对象equals()返回为false,那么它们的hashCode()也应当不一样**
- 在hashMap，hashSet,hashTable,都是先进行hashCode的匹配，如果hashCode不存在，直接插入，
 如果有相同的hashCode,然后才进行equals函数的调用，所以为了使对象在集合中工作正常，那么，equals
 的对象hashCode一定要一样，不equals的对象，hashCode最好也能够不一样

### 计算方法

- 初始化一个整形变量，为此变量赋予一个非零的常数值，比如int result = 17;
- 选取equals方法中用于比较的所有域，然后针对每个域的属性进行计算：
  - 如果是boolean值，则计算f ? 1:0
  - 如果是byte\char\short\int,则计算(int)f
  - 如果是long值，则计算(int)(f ^ (f >>> 32))
  - 如果是float值，则计算Float.floatToIntBits(f)
  - 如果是double值，则计算Double.doubleToLongBits(f)，然后返回的结果是long,再用规则(3)去处理long,得到int
  - 如果是对象应用，如果equals方法中采取递归调用的比较方式，那么hashCode中同样采取递归调用hashCode的方式。
   否则需要为这个域计算一个范式，比如当这个域的值为null的时候，那么hashCode 值为0
  - 如果是数组，那么需要为每个元素当做单独的域来处理,对每一个元素获得值，然后将数组当作一个对象返回一个hashCode。
   也可以使用java.util.Arrays.hashCode方法得到一个值
- 然后将上面每一个域获得的值，调用result = 31*result + c
- 最后返回result

### 注意事项

- 上述计算过程中，**一般都用31乘以前一次返回的result**,因为在性能上会有优化 31*i (i<<5) -i
- 如果**一个对象的hashCode计算比较麻烦，那么可以将对象的hashCode计算，然后保存在对象中**，
 注意的是**存hashCode的值应当被定义为volatile**的
- 不要试图从散列码计算中排除一个对象的关键部分来提高性能

```java

private volatile int hashCode;

@Override
public int hashCode() {
    int result = hashCode;
    if (result == 0) {
        result  = 17;
        result = 31*result + areaCode;
        result = 31*result + prefix;
        result = 31*result + lineNumber;
        hashCode = result;
    }
    return result;
}
```