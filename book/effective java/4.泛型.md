# 泛型

## 不要使用原生类型

- 原生类型在编译期间不会进行类型检查，因而也有失去了泛型在安全性和表达性上的所有优势
- 对于泛型类，**如果可以使用任何类型的对象，应当使用Object作为类型参数**，而不是原生类型

```java
//表示可以存储任何的类型
List<Object> = new ArrayList<>();
```

- 使用instanceOf操作符后，如果不确定是什么类型，应当使用无限制通配符

```java
if (o instanceOf Set) {
    Set<?> set = (Set<?>) o;
}
```

- Collection<?>除了null不能add作何类型



## 消除非受检警告

- 在使用泛型的代码的地方，经常会出现unchecked的警告，而每一个unchecked的警告在运行时都可能出现    ClassCastException,**应当尽可能的消除非受检警告**
- **如果无法消除警告，并且可以证明引起警告的代码是类型安全的，可以用@SuppressWarnings("unckecked")这个注解来禁止警告**
- **应当在尽可能小的范围内使用@SuppressWarnings注解**，永远不要在类上使用@SuppressWarnings注解
- **如果发现自己在长度不止一行的方法或构造函数中使用了@SuppressWarnings,可以将它移到一个局部变量**，在局部变量上使用注解


```java
// arrayList中的方法
public <T> T[] toArray(T[] a) {
    if (a.length < size) {
        @SuppressWarnings("unchecked")
        T[] result = Arrays.copyOf(elements, size,a.getClass());
        return result;
    }
    System.arraycopy(elements, 0, a, 0, size);
    if (a.length > size) {
        a [size] = null;
    }
    return a;
}
```

## 列表优先于树组

- **数组是协变的**，如果Sub是Super的子类，那么Sub[]就是Super[]的子类
- **泛型是固定的**，对于两个不同的类型T1, T2,即使它们之间存在继承关系，List<T1>既不是List<T2>的子类，也不是List<T2>的超类，两者是不同的类型

```java
 // 下面代码在编译期间是可以通过的，但是在运行时会出现错误
 Object[] array = new Long[1];
 array[0] = "test";

 // 下面的代码会compile error
 List<Object> list = new ArrayList<Long>();
 list.add("test);
```

- 数组是具体化的，提供了运行时类型安全，忽略了编译时类型安全，而泛型是在编译期间进行类型约束校验，在运行时因为擦除，被擦除成它的第一个边界，能够提供编译期间的安全更好
- 因为擦除，泛型在运行时的类型信息比编译期间的类型信息要少，因而泛型是不可具体化的类型，**因而不能创建泛型数组**，所以一般情况下**要使用泛型数组，要么考虑使用List, 要么使用Object[]数组，然后内部进行转型**
- **不要混用数组与泛型**


## 优先考虑使用泛型

- 使用泛型，比在调用时进行转型更加简单，也更加安全，所以应当使用泛型


## 优先考虑使用泛型方法

- 使用泛型方法，比要求使用者转换输入参数和返回值，更加简单，所以应当使用泛型方法
- 优先考虑泛型方法，而不是将速个类泛型化
- 常且的泛型方法：**函数对象，递归泛型限制，带边界的自限定泛型**


## 利用有限制通配符来提升API的灵活性

- 为了获取最大的灵活性，**要在表示生产者和消费者的输入参数上使用通配符类型**，如果某个参数既是消费者又是生产生，那么使用通配符就不是那么必要了
- **PECS**：**如果对于一个输入参数，表示一个T生产者，应当使用<? extends T>；如果表示一个T的消费者，应当使用<? super T>**

```java

public class Stack<E> {
    //...

    // 通过使用通配符，可以加入E或E子类的集合
    public void pushAll(Collection<? extends E> collection) {
        for (E e : collecion) {
            push(e);
        }
    }

    // 能过使用通配符，可以将结果返回到E或E超类的集合中
    public void popAll(Collecion<? super E> dst) {
        while (!isEmpty()) {
            dst.add(pop());
        }
    }
}

static <E> E add(List<? extends E> list, Function<E> fuction, E iniValue) {

}

// 通过使用通配符，可以对E子类的list求最大值
public static <T extends Comparable<? super T>> T max(List<? extends T> list) {
}
```

## 类型安全异构容器

- 一般情况下，java中的泛型容器所能有的泛型参数是固定，但有时我们希望，容器中存储的类型有很多种，同时在做插入取值的时候，也能够编译期间的类型安全，这时应当用到异构容器

- 异构容器,主要对于map,主要思想是：**将key参数化，而不是将容器参数化**。其中主要用到的是Class<?>类型

- 重点：**在异构容器为了确保类型安全，使用class的cast方法**

```java
public class Favorites {
    private Map<Class<?>, Object> favourites = new HashMap<>();

    public <T> void put(Class<T> classType, T instance) {
        if (classType == null) {
            throw new NullPointerException("class type is null");
        }

        // 使用泛型的类型转换，确保类型安全
        favourites.put(classType, classType.cast(instance));
    }

    public <T> T get(Class<T> classType) {
        if (classType == null) {
            return null;
        }
        // 进行转换
        return classType.cast(favourites.get(classType));
    }
}
```