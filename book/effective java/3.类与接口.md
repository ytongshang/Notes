# 类与接口

## 使类与成员的可访问性最小化

- 原则：**尽可能使类或类的成员不被外界访问**

### 类与接口的可访问性

- 对于顶层的类与接口，访问性只能是public或都包访问级别的
- 类与接口，如果它是public的，那么它就是包的导出api的一部分，那么有责任永远的支持它
- 但是如果它是包访问级别的的，那么它就是包的实现的一部分，以后对这部分修改、替换、删除，都不用担心现有的客户端程序
- 如果一个包访问级别的类只在一个类的内部被用到，那么应当考虑使它成为那个唯一使用它的那个类的的私有嵌套类

### 类成员的可访问性

- private
- 包访问级别
- protected,**子类以及声明该成员的包内部的任何类也可以访问这个成员，protected具有包访问权限的一切特性**
- public
- 一般情况下，都会将成员变成私有的，**只有当包内的另一个类真正需要访问这个成员时，才将其声明为包访问级别的**
- 对于**公有类的protected成员，其也是公有类的导出API的一部分**，必须永远得到支持，所以**protected的成员应当尽可能的少用**
- 为了测试，可以将private成员变成包访问级别的，但是绝对不能变成不能高于包访问级别
- **public类的成员变量，绝不能是公有的**，如是成员变量是非final的，或者是一个指向可变对象的final引用，那么一旦使这个成员变量变成公有的，那么就放弃了对
 存储在这个成员变量中的值进行限定的方法，**包含公有可变成员变量的类绝对不是线程安全的**
- 对于static成员变量，上述对public成员变量的规则同样适用。
- 对于static成员变量，只有static final可以声明为public这一种例外，**static final的成员变量要么包含基本类型，要么包含指向不可变对象的引用**，
 **如果final成员变量包含可变对象的引用，那么它便具有final成员变量的所有缺点，引用本身不可变，但是引用的对象却可以被修改**
- 长度非0的数组总是可变的，所有类具有public static final数组成员变量，或者返回这种成员变量的访问方法，这几乎总是错误的
 解决办法是返回对象的clone,或都返回对应的不可修改的collection

```java

// public static final 数组总是有问题的
public static final Thing[] VALUES = {...};

private static final Thing[] PRIVATE_VALUES = {...};
public static final List<Thing> VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES);)

private static final Thing[] PRIVATE_VALUES = {...};
public static final Thing[] values() {
    return PRIVATE_VALUES.clone();
}
```




## 在公有类中使用访问方法而不是公有域

- **对于public类，对于类中的成员变量，应当使用public访问方法，而不是直接将成员变量设为public**，
 其原因是使用public方法访问变量，可以保留将来改变该类的内部表示方法的灵活性
- 而对于包访问权限的类，或者私有的嵌套类，直接暴露它成员变量，并没有本质上的错误
- 对于公有类，可以使用public static final的成员变量，但是要求该成员变量要么是基本类型，或者指向不可变的对象，
 使用public static final 变量指向不可变的对象造成的危害要小一些
- 结论：**公有类永远不应当暴露可变的成员变量，在特定情况下，可以暴露不变变的对象（比如static final对象）**，
 **对于包访问级别或者私有的嵌套类直接暴露成员变量，是可以接受的**




## 使可变性最小化

### 不可变类

- 定义：实例不能被修改的类，每个实例中包含的所有信息都必须在创建该对象的时候提供，并在整个对象的生命周期内固定不变
- 不可变对象的原则
  - 所有的成员变量都是私有的
  - 所有的成员变量都是final的
  - 不要提供任何修改对象成员变量的方法(实际上是没有一个方法能够使对象采生外部可见的改变)
  - 保证类不会被扩展(**类被声明为final,或者所有的构造函数变成private,包访问级别的，并声明公有的静态工厂方法来代替公有的构造器**)
  - **确保对于任何可变组件的互斥访问，比如类中的指向可变对象的域，则必须确保该类的客户端无法获得这类对象的引用，**
   **也不要用客户端提供的对象来初始化可变对象的域，也不要有任何方法返回这类对象的引用**

- 不可变对象的特点：
  - 对于可变对象有一些函数类操作，**返回值是一个新的对象，而不是在原先的对象上修改状态**，比如String类对象
  - 不可变对象本质上线程安全的，它们不要求同步
  - 不可变对象可以自由的被共享，不可变类应当充分利用这种优势，鼓励客户端尽可能的重有现有的对象，一种常用的方法定义常用对象
   的public static final对象，或者采用静态工厂的方法利用缓存来返回对象（比如Collections.emptyList()等）
  - 不可变对象可以自由地被共享，因而不需要为不可变对象提供拷贝构造函数，不需要提供保护性拷贝（返回原先对象的拷贝而不是原先对象）
  - 不可变对象不仅可以共享不可变对象，还可以共享它们内部的信息（比如BigInteger的negate()方法的返回值）

- 缺点：对于每个不同的值都需要一个单独的对象，可能在性能有所降低，解决办法一个是预测会有哪些操作，然后将它们作为基本类型提供，
 另一种解决方法就是提供不可变对象的可变适配类（比如String和StringBuilder）

- 如果让不可变对象实现序列化，并且它包含一个或者多个指向可变对象的成员变量，那么必须显示提供readObject或者readResollve,或者使用
 ObjectOutputStream.writeUnshared和ObjectInputStream中的readUnShared。

### 可变性最小化

- 如果没法使类变成不可变的，那么就应当尽可能的限制它的可变性，从而减少对象可以存在的状态数
- 除非有理由让成员变量变成非final的，那么成员变量就应当是final的
- 坚决不要为每一个get方法设置一个set方法
- **一般不要为对象提供可以重新初始化的方法**（这种方法是对象可以被重用，就好像这个对象是由另一个不同的初始状态构造出来的一样，
 因为在性能上重新初始化并没有带来很大的优势




## 复合优先于继承

### 继承的劣势

- 类继承，与方法调用不同，继承打破了封装性
- 导致子类脆弱的一个原因，就是我们在重写超类的方法时，**依赖于我们对于超类方法实现细节的了解**
 另一方面，哪怕我们在子类中只增加新的方法而不重写超类方法，也有可能因为将来超类新增与子类同签名的方法而出现问题

### 使用复合

- 不扩展现有的类，而是在**新的类增加一个引有现有类实例的私有成员变量，然后将私有成员变量的功能转发出去**。
- 复合更好的形式是，**新增的类和想要扩展的类实现了同样的接口**，就是一个“装饰者模式”

### 复合 VS 继承

- 使用复合而不是继承，可以**避免暴露类具体的实现细节**
- 复合类可以隐藏想要扩展的类中有缺陷的API
- **只有当子类与超类之间确实存在子类型关系的时候，才使用继承**
- 当超类与子类在不同的包时，又或者超类并不是为了继承而设计的，使用继承会导致新的类很“脆弱”
- 使用复合而不是继承，特别是包装类与原来的类实现相同的接口时，会使包装类更加健壮，也更加的强大




## 要么为继承设计，并提供文档，要么就禁止继承

### 专为继承而设计的类

- 该**类必须有文档描述它可以被Override的方法的自用性**，也就是对于每个public或者protected或构造函数，
 它文档必须指明该方法或者构造函数调用了哪些可以Override的方法，是以什么顺序用的，每个调用的结果又是如何影响
 后续的处理结果的。
- **类必须通某种方式提供合适的钩子**，以使能够进入到它的内部工程流程中，这种形式可以是精心选择的protected方法或者域
- 对于可能被广泛使用的专为继承的类，对于文档中所说明的自用性，以及对于其protected的方法和成员变量所隐含的实现策略，
 实际上已经**做了永久承诺**，所以在发布类之前必须编写类进行测试
- 对于专为继被而生的类，**构造函数中绝对不能调用可以被Override的方法，也就是构造函数中只能调用final方法**
- 对于专为继被而生的类，**如果实现了Serializable或者Cloneable接口，那么无论是clone()还是readObject()方法，**
 **无论直接还是间接都不能够调用可以被Override的方法**
- 对于专为继承而生的类，如果**继承了Serializable,如果类有一个readResolve或者有writeReplace,那么这两个方法必须是protected,不能是private的**，
 否则子类会忽略掉这两个类

### 最佳实践

- **对于那些并非为了安全地进行子类化而设计和编写文档的类，要禁止子类化**，原理是final类，或者包访问级别，private的构造函数，并提供静态工厂方法
- **使用复合而非继承，使用包装类**
- 对于一般的**可以被继承却又没有专门为子类化设计的类来说，最好不要调用它的任何可能被Override的方法**，解决方法一种手动是消除类中可Override方法的自用性，
 另外一种方法就是**将每个可以被Override方法中的代码转移到一个private的辅助方法中，并且让每个可以被Override的方法调用它的私有辅助方法**，
 然后**用“直接调用可以被Override的私有辅助方法”来代替“可Override方法的自用调用”**
