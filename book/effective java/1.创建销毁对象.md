# 创建销毁对象

## static 工厂方法

- 使用具名static工厂方法创建对象，而不是构造函数
- 常用的具名static工厂方法，valueOf(),of(),getInstance(),newInstance(),getType(),newType()
- 优势：具名，可以返回要创建对象的子类，不必每次调用都创建一个对象，创建泛型参数对象时简洁
- 缺点：类必须有public 或包级别的构造函数，所以**一般用包级别的**

## Builder模式

- 如果构造器的参数较多，并且部分是可选的话，考虑使用Builder模式

- example

```java
public class NutritionFacts {
    private final int servingSize;
    private final int servings;
    private final int calories;
    private final int fat;

    public static class Builder {
        private final int servingSize;
        private final int servings;

        // Optional parameters - initialized to default values
        private int calories = 0;
        private int fat = 0;

        public Builder(int servingSize, int servings) {
            this.servingSize = servingSize;
            this.servings = servings;
        }

        public Builder calories(int val) {
            calories = val;
            return this;
        }

        public Builder fat(int val) {
            fat = val;
            return this;
        }
    }

    public NutritionFacts(Builder builder) {
        servingSize = builder.servingSize;
        servings = builder.servings;
        calories = builder.calories;
        fat = builder.fat;
    }
}
```

## 单例模式

- 常用的有4种方法,分别用class加载就初始化唯一单例，double-checking,枚举 三种方式来创建
- **一定记得要加volatie关键字**
- 构造方法一定要私有化
- 枚举创建方法是最被推荐的
- 如果采用枚举以外的其它方法创建单例的时候，**如果要实现序列化，要注意两点，一是所有的成员变量应当变成transient的，**
 **二是应当新增一个readResolve()的方法**


```java
public class SingleTon {
    public static final volatile INSTANCE = new SingleTon();

    public static SingleTon getInstance() {
        return INSTANCE;
    }

    private SingleTon() {}
}
```

```java
public class SingleTon {
    public static class SingleTonHolder {
        public static final volatile SingleTon INSTANCE = new SingleTon();
    }

    public static SingleTon getInstance() {
        return SingleTonHolder.INSTANCE;
    }

     private Singleton () {}
}

```


```java
public class SingleTon implements Serializable{
    public static transient volatile INSTANCE = null;

    public static SingleTon getInstance() {
        if (INSTANCE == null) {
            synchronized(SingleTon.class) {
                if (INSTANCE == null) {
                    INSTANCE = new SingleTon();
                }
            }
        }
        return INSTANCE;
    }

     private SingleTon() {}

     protected Object readResolve() {
        return getInstance();
    }
}
```

```java

public enum SingleTon {
    INSTANCE;

    public static SingleTon getInstance() {
        return INSTANCE;
    }
}
```