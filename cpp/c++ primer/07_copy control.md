# Copy control


1.    第一个参数是自身类类型对象的引用（常用 const 修饰），且任何额外参数都有默认值的构造函数称为拷贝构造函数，
   拷贝初始化使用 = 符号，而直接初始化将初始化式放在圆括号中。
string dots(10,'.');
string s(dots)              //直接初始化
string s2 = dots;           //拷贝初始化
以下其它情况也会发生拷贝初始化：
将一个对象作为实参传递给一个非引用类型的形参
从一个返回类型为非引用类型的函数返回一个对象
用花括号列表初始化一个数组中的元素或一个聚合类中的成员

2.    如果转换构造函数是explicit，使用拷贝构造函数和直接初始化是有区别的
vector<int> v1(10);
vector<int> v2 =10 ;          //错误，explicit
void f(vector<int>);
f(10);                        //错误，explicit
f(vector<int>(10));


3.    大多数操作符可以定义为成员函数或非成员函数。当操作符为成员函数时，它的第一个操作数隐式绑定到 this 指针。有些操作符（包括赋值操作符）必须是定义自己的类的成员。因为赋值必须是类的成员，所以 this 绑定到指向左操作数的指针。因此，赋值操作符接受单个形参，且该形参是同一类类型的对象,其右侧运算对象作为显示参数传递。赋值操作符也返回对同一类类型的引用。
     class Sales_item 
    {
     public:
         // other members as before
         // equivalent to the synthesized assignment operator
         Sales_item& operator=(const Sales_item &);
    };
//两个引用，返回普通引用，右操作数常引用
拷贝构造函数和赋值操作符基本一起使用，要么两者都不用自己定义，用自动生成的合成版本，要么两者都自己定义

4.    构造函数先初始化再执行构造函数的函数体，而对于析构函数先执行函数体，再销毁成员。
       析构函数的成员销毁取决于类型，类类型调用其析构函数，内置类型没有析构函数，因而隐式销毁一个内置指针类型的成员不会delete它所指向的对象，因而在析构函数中要手动delete指针所指向的对象。
          智能指针是类类型，因而具有析构函数。

5.    变量在超出作用域时应该自动销毁，当对象的引用或指针超出作用域时，不会运行析构函数。
        许多类不需要显式析构函数，尤其是具有构造函数的类不一定需要定义自己的析构函数。仅在有些工作需要析构函数完成时，才需要析构函数。析构函数通常用于释放在构造函数或在对象生命期内获取的资源。
       如果类需要自定义析构函数，则它也需要自定义赋值操作符和复制构造函数，这是一个有用的经验法则。这个规则常称为三/五法则，指的是如果需要析构函数，则需要所有这三个拷贝控制成员。
        所以，对于分配了资源的类一般需要自定义析构函数以释放那些资源，根据上面的三法则，所以也应当定义复制构函数和赋值操作符。

6.     对象的拷贝构造函数与拷贝赋值运算符基本上是成对出现的，但是有自定义的这两个函数，不一定需要自定义析构函数
可以使用 = default要求编译器生成合成版本的默认构造函数，拷贝构造函数，析构函数，拷贝赋值运算符

7.    阻止拷贝 ，就是将拷贝函数与拷贝赋值运算符定义为删除的函数，常见的阻止拷贝的类有iostream
struct NoCopy
{
    NoCopy() = default;
    NoCopy(const NoCopy&) =delete;
    NoCopy& operator=(const NoCopy&) = delete;
}
delete可以应用于任何函数，但是主要用来阻止拷贝控制成员 

8.    析构函数不能是删除的函数，如果析构函数是删除的函数，不能定义该类型的变量或释放指向该类型动态分配对象的指针，但是可以动态分配这种类型的对象
       如果一个类有数据成员不能默认构造，拷贝，复制或者销毁，对应的默认构造，拷贝，复制或者销毁成员函数就被定义为删除的
       对于具有引用成员或无法默认构造的const成员的类，编译器不会为其合成默认构造函数函数
       如果一个类有const成员，它不能使用合成的拷贝赋值运算符（const不能赋值）
       有引用成员的类，合成拷贝赋值运算符被定义为删除的
       C++11以前，通过将拷贝构造函数和拷贝赋值运算符声明为private来阻止拷贝，同样为了阻止友员和成员函数拷贝，将拷贝成员声明为private的，但是不定义它们。

9.    管理类外资源的类必须定义拷贝控制成员，也必须定义析构函数来释放对象分配的资源，定义拷贝操作时，可以使类的形为像一个值或者一个指针。

       行为像值，它有自己的状态，当拷贝一个像值的对象时，副本和原对象是完全独立的。 对于如下的类需要做的事如下：
定义一个拷贝构造函数，完成string拷贝，而不是拷贝指针
定义析构函数来释放string
定义一个拷贝赋值运算符来释放对象当前的string，并从右边运算对象拷贝string
class HasPtr
{
public:
    HasPtr(const std::string &= std::string()):
        ps(new std::string(s),i(0)) {}
    HasPtr(const HasPtr &p):
        ps(new std::string(*p.ps)),i(p.i){}
    HasPtr& operator = (const HasPtr &);
    ~HasPtr() {delete ps;}
​
private:
    std::string *ps;
    int i;
}
拷贝复制运算符，正确的做法是先拷贝右侧运算对象，以处理自赋值情况，防止自赋值时自身资源被释放无法再赋值给新资源。然后释放左侧运算对象资源，再更新左侧的资源
HasPtr& HasPtr::operator= (const HasPtr& rhs)
{
    auto newp = new string(*rhs.ps);
    delete ps;
    ps = newp;
    i = rhs.i;
    return *this;
}
       
       行为像指针，自定义拷贝构造函数与拷贝赋值运算符，拷贝指针本身而不是对象，自定义析构函数时特别要注意不能单方面的释放资源，只有当最后一个用到资源的对象销毁时，才能释放资源。




 


