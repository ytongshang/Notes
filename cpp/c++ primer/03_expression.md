# Expression

## 左值与右值

- **当一个对象被用作右值的时候，用的是对象的值(内容)：当对象被用作左值的时候，用的是对象的身份(在内存中的位置)**
- **对于左值可以执行取地址操作**
- **在需要右值的地方可以用左值来代替，但是不能把右值当左值使用**
- **如果表达式的值是左值，那么decltype作用于该表达式（不是变量），得到的是一个引用类型**

- 常见的用到左值的地方：
    - 赋值，a=b,a为非const左值对象，返回左值
    - 取地址，作用于左值对象，所得的指针是一个右值，int *pa = &a;a为左值对象，pa为右值
    - 内置解引用，下标运算符，迭代器解引用，string，vector的下标运算符的结果为左值
    - 递增递减运算符作用于左值，++a，--a,其前置版本所得结果也是左值
    
## 求值顺序
- 明确定义了运算对象求值顺序：&&,||,?:和逗号运算符
- 如果改变了某个运算对象的值，在表达式的其它地方不要再使用这个运算对象，因为同一个表达式中的运算对象的求值顺序是没有
 规定的
 
 
## 算术运算符

- **C++11规定除法的商一律向0取整，也就是直接切除小数部分**，比如将-3.6,-3.2转换为整数都是向0取整，都是-3
- m%n的符号与m相同
- (-m)/n,m/(-n)都等于-(m/n)
- m%(-n)等于m%n,(-m)%n等于-（m%n）

## 逻辑与关系运算符

- **除非进行比较运算时运算对象是布尔类型，否则不要使用布尔字面值true与false作为运算对象**

```c++
// 正确作法
if（val） {...}
if(!val) {...}

// 可能出现的错误
int val = 2;
// 因为小整型会自动转换为整型，所以true->1,所以只有当val=1时，val==true才为真，其它都是假
if (val == true) {...}
```

## 赋值运算符

- 赋值运算符的左侧必须是一个可以修改的左值
- 赋值运算符的结果是左侧的运算对象，并且也是一个左值
- 采用初始值列表的方式初始化，**如果左侧运算对象是内置类型，那么初始值列表最多只能包含一个值，而且该值即使转换的话其所占空间也不大于目标空间**
- 无论左侧的运算对象是什么，初始值列表都可以为空，此时编译器会创建一个值初始化的临时变量，并且赋给左侧的对象
 
 ```c++
 int k = 0;
 k = {3.14}      //错误，列表初始化不能将double转为int
 ```
 
## 自增自减运算符

- **前置版本将对象本身作为左值返回，后置版本则将对象初始值的副本作为右值返回**
- **除非必须，否则不用自增自减运算符的后置版本**

```c++
auto pbeg = v.begin();
while(pbeg != v.end() && *pbeg >= 0) {
    cout << *pbeg++ <<endl;
    // 由于后置自增运算符的优先级高于解引用运算符，实际相当于*(pbeg++), 将pbeg的值加1，并且返回运算前对象值的副本
}
```

## 箭头运算符与点运算符

- 箭头运算符作用于一个指针类型的运算对象，结果是一个左值
- 点运算符分为两类：如果成员所属的对象是左值，那么结果是左值，如果成员所属的对象是右值，那么结果是右值

## 位运算符

- 求反：~
- 左移：<<
- 右移：>>
- 位与：&
- 位异或：^
- 位或：|

- 一般只用位运算符去处理unsigned类型
- 左移在右侧插入值为0的二进制位，
- 右移的行为依赖其左侧的运算对象的类型：
   - 如果运算对象是无符号类型，在左侧插入值为0的二进制位
   - 如果该运算对象是带符号类型，在左侧插入符号位的副本或值为0的二进制位，视具体环境而定

## sizeOf运算符

- sizeof运算符返回一个表达式或一个类型名字所占的字节数

```c++
sizeof (type)
sizeof expr
```

- sizeof满足右结合律，**返回类型是一个size_t的类型的常量表达式，可以做数组的容量等**

```c++
Sales_data data, *p;
sizeof(Sales_data);         //存储Sales_data的空间大小
sizeof data;                // 同sizeof(Sales_data)
sizeof p;                   // 指针所占的空间大小
sizeof *p;                  // 同sizeof(Sales_data),p不需要有效
sizeof data.revenue         // Sales_data 中间revenue成员对应类型的大小
sizeof Sales_data::revenue  // 另一种获得revenue成员大小的方式
```

- sizeof不会实际求算对象的值，所以即使p是一个无效（没有初始化）的指针，sizeof也不会有什么影响

- 常见的结果
    - sizeof char 返回1
    - 对引用类型，返回被引用对象所占空间的大小
    - 对于指针类型，返回指针本身所占空间的大小
    - 对解引用指针执行sizeof运算得到指针指向的对象所占的空间大小，指针不需要有效












