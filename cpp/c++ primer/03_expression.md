# Expression

## 左值与右值

- **当一个对象被用作右值的时候，用的是对象的值(内容)：当对象被用作左值的时候，用的是对象的身份(在内存中的位置)**
- **对于左值可以执行取地址操作**
- **在需要右值的地方可以用左值来代替，但是不能把右值当左值使用**
- **如果表达式的值是左值，那么decltype作用于该表达式（不是变量），得到的是一个引用类型**

- 常见的用到左值的地方：
    - 赋值，a=b,a为非const左值对象，返回左值
    - 取地址，作用于左值对象，所得的指针是一个右值，int *pa = &a;a为左值对象，pa为右值
    - 内置解引用，下标运算符，迭代器解引用，string，vector的下标运算符的结果为左值
    - 递增递减运算符作用于左值，++a，--a,其前置版本所得结果也是左值
    
## 求值顺序
- 明确定义了运算对象求值顺序：&&,||,?:和逗号运算符
- 如果改变了某个运算对象的值，在表达式的其它地方不要再使用这个运算对象，因为同一个表达式中的运算对象的求值顺序是没有
 规定的
 
 
## 算术运算符

- **C++11规定除法的商一律向0取整，也就是直接切除小数部分**，比如将-3.6,-3.2转换为整数都是向0取整，都是-3
- m%n的符号与m相同
- (-m)/n,m/(-n)都等于-(m/n)
- m%(-n)等于m%n,(-m)%n等于-（m%n）

## 逻辑与关系运算符

- **除非进行比较运算时运算对象是布尔类型，否则不要使用布尔字面值true与false作为运算对象**

```c++
// 正确作法
if（val） {...}
if(!val) {...}

// 可能出现的错误
int val = 2;
// 因为小整型会自动转换为整型，所以true->1,所以只有当val=1时，val==true才为真，其它都是假
if (val == true) {...}
```

## 赋值运算符

- 赋值运算符的左侧必须是一个可以修改的左值
- 赋值运算符的结果是左侧的运算对象，并且也是一个左值
- 采用初始值列表的方式初始化，**如果左侧运算对象是内置类型，那么初始值列表最多只能包含一个值，而且该值即使转换的话其所占空间也不大于目标空间**
- 无论左侧的运算对象是什么，初始值列表都可以为空，此时编译器会创建一个值初始化的临时变量，并且赋给左侧的对象
 
 ```c++
 int k = 0;
 k = {3.14}      //错误，列表初始化不能将double转为int
 ```
 
## 自增自减运算符

- **前置版本将对象本身作为左值返回，后置版本则将对象初始值的副本作为右值返回**
- **除非必须，否则不用自增自减运算符的后置版本**

```c++
auto pbeg = v.begin();
while(pbeg != v.end() && *pbeg >= 0) {
    cout << *pbeg++ <<endl;
    // 由于后置自增运算符的优先级高于解引用运算符，实际相当于*(pbeg++), 将pbeg的值加1，并且返回运算前对象值的副本
}
```












