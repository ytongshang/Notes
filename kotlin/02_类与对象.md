# 类与对象

## 构造函数

-   一个主构造函数，可能有一个或多个次构造函数
-   主构造函数不能包含任何代码，初始化代码放 init 代码块中
-   实例化
    -   **主构造函数的参数可以在初始化块中使用**
    -   **主构造函数的参数可以在属性初始化器中使用**
    -   初始化块按照它们出现在类体中的顺序执行，与属性初始化器交织在一起

```kotlin
class KotlinPerson constructor(name: String) {
    private var _name = "default"

    init {
        println("init block")
        println(_name)
        _name = name
        println(_name)
    }

    override fun toString(): String {
        return "KotlinPerson:$_name"
    }
}


val test = KotlinPerson("Kotlin")

// init block
// default
// Kotlin
```

-   **可以与 Typescript 一样，在构造函数中声明属性，并且初始化**
    -   可以加上 public,protected,private 等修饰符
    -   可以使用 val 与 var

```kotlin
class KotlinPerson2 constructor(val name: String)

val test2 = KotlinPerson2("Kotlin2")
println(test2.name)

// Kotlin2
```

### 次级构造函数

-   如果类有一个主构造函数，每个次构造函数需要委托给主构造函数，可以通过直接委托或者通过别的次构造函数间接委托

```kotlin
class KotlinPerson2 constructor(name: String) {
    private val _name: String = name
    private var _age: Int = 1
    private var _gender : String = "female"

    constructor(name: String, age: Int) : this(name) {
        this._age = age
    }

    // 可以委托给其它构造函数，间接委托给主构造函数
    constructor(name: String, age: Int, gender: String): this(name, age) {
        this._gender = _gender
    }
}
```

-   **委托给主构造函数会作为次构造函数的第一条语句，因些所以初始化块中的代码都会在次构造函数体之前执行**

## 继承

-   默认超类为 Any
-   派生类必须主动调用基类的构造函数
-   **Kotlin 中类默认为 final,要想继承必须加 open**

```kotlin
open class Parent(name :String) {
    private val name: String = name
}

class Child(name:String) : Parent(name){
}
```
