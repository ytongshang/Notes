# 类与对象

-   [构造函数](#构造函数)
    -   [次级构造函数](#次级构造函数)
-   [继承](#继承)
    -   [属性覆盖](#属性覆盖)
    -   [派生类初始化顺序](#派生类初始化顺序)
    -   [super](#super)

## 构造函数

-   一个主构造函数，可能有一个或多个次构造函数
-   主构造函数不能包含任何代码，初始化代码放 init 代码块中
-   实例化
    -   **主构造函数的参数可以在初始化块中使用**
    -   **主构造函数的参数可以在属性初始化器中使用**
    -   初始化块按照它们出现在类体中的顺序执行，与属性初始化器交织在一起

```kotlin
class KotlinPerson constructor(name: String) {
    private var _name = "default"

    init {
        println("init block")
        println(_name)
        _name = name
        println(_name)
    }

    override fun toString(): String {
        return "KotlinPerson:$_name"
    }
}


val test = KotlinPerson("Kotlin")

// init block
// default
// Kotlin
```

-   **可以与 Typescript 一样，在构造函数中声明属性，并且初始化**
    -   可以加上 public,protected,private 等修饰符
    -   可以使用 val 与 var
    -   **只允许在主构造函数中声明变量**

```kotlin
class KotlinPerson2 constructor(val name: String)

val test2 = KotlinPerson2("Kotlin2")
println(test2.name)

// Kotlin2
```

### 次级构造函数

-   如果类有一个主构造函数，每个次构造函数需要委托给主构造函数，可以通过直接委托或者通过别的次构造函数间接委托

```kotlin
class KotlinPerson2 constructor(name: String) {
    private val _name: String = name
    private var _age: Int = 1
    private var _gender : String = "female"

    constructor(name: String, age: Int) : this(name) {
        this._age = age
    }

    // 可以委托给其它构造函数，间接委托给主构造函数
    constructor(name: String, age: Int, gender: String): this(name, age) {
        this._gender = _gender
    }
}
```

-   **委托给主构造函数会作为次构造函数的第一条语句，因此所有初始化块中的代码都会在次构造函数体之前执行**

## 继承

-   所在为的超类默认为 Any
-   派生类必须主动调用基类的构造函数
-   **Kotlin 中类默认为 final,要想继承必须加 open**
-   **Kotlin 中方法默认是 final,子类想要重写覆盖必须加 open**
-   **final 类中所在方法默认为 final 的，方法前 open 不起作用**
-   **标记为 override 的成员本身子类可以覆盖，如果想禁止再次覆盖，加上 final 关键字**

```kotlin
open class Parent(name :String) {
    private val name: String = name
    open fun v(){}
}

class Child(name:String) : Parent(name){
    override fun v(){}
}
```

### 属性覆盖

-   支持属性的 override，必须加上 override 关键字,必须是兼容的类型
-   **每个声明的属性可以由具有初始化器的属性或具有 getter 方法的属性覆盖**
-   **可以使用 var 属性覆盖 val 属性，反之不行**，因为 val 本质是声明了一个 getter 方法，覆盖为 var 只是额外声明了一个 setter 方法
-   可以在主构造函数中使用 override 关键字作为属性专明的一部分

```kotlin
open class Parent(name: String) {
    private var name: String = name
    // 想要覆盖，必须加open
    protected open val family : String  = "ParentUnknown"

    open fun family() : List<String> {
        return ArrayList()
    }
}

class Child(name:String) : Parent(name){
    private var age:Int = 0

    // 用getter方法覆盖
    override val family: String
        get() = super.family

    // 使用初始化器覆盖
    // override val family: String = "ChildUnknown"

    constructor(name: String, age : Int) : this(name) {
        this.age = age
    }

    override fun family(): List<String> {
        return ArrayList()
    }
}
```

```kotlin
// 接口可以有属性
interface Foo {
    val count :Int
}

// 主构造函数中的属性重写
class Bar1(override val count: Int) :Foo
```

### 派生类初始化顺序

-   初始化顺序

    -   基类构造函数参数的求值
    -   基类从上到下的 init block 与属性初始化器
    -   基类的构造函数
    -   子类的从上到下的 init block 与属性初始化器
    -   子类的构造函数

-   基类的初始化发生在派生类的初始化逻辑运行之前
-   **避免在构造函数,属性初始化器以及 init 块中使用 open 成员**

```kotlin
open class Base(name: String) {
    private var _name:String = "Base"
    private var age:Int = 0

    init {
        println("Base before init : $_name")
        this._name = name
        println("Base init block")
    }

    constructor(name :String, age :Int) :this(name){
        this.age = age
        println("Base Constructor")
    }
}

class Derived(name :String, age :Int) : Base(name, age){
    private var gender: String = "female"

    init {
        println("Derived init block")
        println("Derived:$name")
    }

    constructor(name: String, age :Int, gender : String):this(name, age){
        this.gender = gender
        println("Derived constructor")
    }
}

fun main(args : Array<String>) {
    var test = Derived("John", 10, "male")
    println(test)
}

// Base before init : Base
// Base init block
// Base Constructor
// Derived init block
// Derived:John
// Derived constructor
// rancune.kotlin.oop.Derived@49476842
```

### super

-   **可以用 super 调用其超类的函数与属性访问器的实现**
-   **f 函数中，可以通过 super 调用其超类的 g 函数**
-   **内部类中访问外部类的超类，通过 super@外部类来使用**
-   **如果一个类从它的直接超类继承相同成员的多个实例，它必须覆盖这个成员并提供自己的实现**

```kotlin
open class Base(name: String) {
    private val name: String = name

    open val x : Int get() = 1

    open fun f() {
        println("Base f")
    }

    open fun g(){
        println("Base g")
    }
}

class Derived(name: String) : Base(name) {

    override val x: Int
        get() = super.x

    // 普通函数重写
    override fun f() {
        super.f()
        // 调用Base中的方法f()
        //super<Base>.f()
        println("Derived f")
    }

    // g中通过super调用其超类的f函数
    override fun g() {
        super.g()
        super.f()
        println("Derived g")
    }

    inner class Baz {
        fun h() {
            // 调用外部类Derived的超类也就是Base中的f
            super@Derived.f()
             // 调用外部类Derived的超类也就是Base中的x
            println(super@Derived.x)
        }
    }
}
```

### abstract

-   可以用一个抽象成员覆盖一个非抽象的 open 成员

```kotlin
open class Base {
    open fun f() {}
}

abstract class Derived :Base() {
    override abstract fun f()
}
```

## 属性与字段

-   var, val
-   set 与 get 方法
-   set 与 get 方法中的幕后字段 field
    -   set/get 方法其中之一使用了默认的实现
    -   set/get 方法中使用了 field
-   幕后属性

```kotlin
class Property {
    // 在set/get方法中因为递归调用的问题，只能使用幕后字段field
    var name: String = "Paul"
        set(value) {
            field = value.trim()
        }
        get() {
            println(field)
            return field
        }

    // set/get方法可以设置可见性
    // get方法的可见性必须和成员的可见性相同
    var setterVisibility: String = "abc"
        private set

    // get方法可以加上注解
    var setterWithAnnotation : Any? = null
        @NotNull get

    // 幕后属性
    private var _size: Int = 0
    // 内部_size有自己的setter与getteer
    // isEmpty只读，使用_size本身的值
    val isEmpty: Boolean
        get() = _size == 0
}
```

### const

-   位于顶层或者是 object 的一个成员
-   用 String 或原生类型值初始化
-   没有自定义 getter

### 延迟初始化属性与变量

-   变量必须用属性初始化器/getter/构造函数初始化
-   可以使用 lateinit 标记，去掉非空检查
-   isInitialized 判断是否初始化过

```kotlin
class Property {
lateinit var subject: Any
}


var test = Property()
if (test::subject.isInitialized) {
}
```

### 接口

-   **kotlin 中的接口既包含抽象方法的声明，也包含实现，与抽象类不同，无法保存状态**
-   接口中可以有属性
    -   要么抽象，要么提供访问器的实现
    -   **接口中声明的属性不能有幕后字段(backing field),接口声明的访问器不能引用它们**

```kotlin
package rancune.kotlin.oop

/**
 * Created by Rancune@126.com on 2019/3/4.
 */
interface MyInterface {
    // 抽象的
    var p1 : String

    // 有get方法
    val p2: String
        get() = "Smith"

    // set/get方法不能有幕后字段
    var p3: String
        set(value) {}
        get() {return "Hello World"}

    // 不实现
    fun f()

    // 接口方法可以有实现
    fun g() {
        println("MyInterface.p3: $p3")
    }
}

class Person : MyInterface {
    override var p1: String = ""

    override fun f() {
    }
}

fun main(args: Array<String>) {
    val p = Person()
    p.g()    // MyInterface.p3: Hello World
}
```

## 可见性

-   public,internal,protected, private
-   外部类不能访问内部类的 private 成员
-   覆盖 protected 成员，并且没有显示指定其可见性，还是 protected

## 扩展

### 扩展函数

-   定义扩展函数

```kotlin
fun <T> MutableList<T>.swap(index1: Int, index2: Int) {
    val tmp = this[index1]
    this[index1] = this[index2]
    this[index2] = tmp
}

val list = mutableListOf(1, 2, 3)
list.swap(1, 2)
println(list)  // 1, 3, 2
```

-   **扩展并不是真正的修改他们所扩展的类，实际上只是去调用定义的扩展函数，因此它们不是根据接收者的虚方法**

```kotlin
open class C1

class C2 : C1()

fun C1.foo() = "c1"

fun C2.foo() = "c2"

fun printFoo(c : C1) {
    println(c.foo())
}

val c1 = C1()
printFoo(c1)  // c

val c2 = C2()
// 输出仍然为c,是由定义的时候的类型决定，并不是由运行时类型决定的
printFoo(c2) // c
```

-   **如果一个类定义有一个成员函数与一个扩展函数，两者函数签名相同，那么总是会调用成员函数**

### 可空接收者

```kotlin
fun Any?.toString():String {
    if (this == null) {
        return "null"
    }
    return toString()
}
```

### 扩展属性

-   支持拓展属性
-   不是实际修改类，所以幕后字段无效

```kotlin
val <T> List<T>.lastIndex: Int
    get() {return this.size - 1}
```

### 伴生对象的扩展

```kotlin
class MyClass {
    companion object {
        private val desc: String = "obj"
    }
}

MyClass.foo()
```

### 拓展声明成员

-   可以在一个类内部为另一类声明扩展
-   定义方法所在的类，分发接受者，为之定义扩展方法的类叫作扩展接受者
-   **如果分发接收者与扩展接受者的成员名字冲突，扩展接受者优先**

```kotlin
class D {
    fun bar() {}
}

class C {
    private fun baz() {

    }

    private fun D.foo() {
        // D.bar() 扩展接受者
        bar()
        // C.baz() 分发接受者
        baz()
    }

    fun D.f() {
        toString()
        this@C.toString()
    }

    fun caller(d : D) {
        d.foo()
    }
}
```

-   **分发接受者是多态的，扩展接收者是静态的**

```kotlin
open class A

class A1: A()

open class B {
    open fun A.foo() {
        println("A.foo in B")
    }

    open fun A1.foo() {
        println("A1.foo in B")
    }

    fun caller(a: A) {
        a.foo()
    }
}

class B1: B() {
    override fun A.foo() {
        println("A.foo in B1")
    }

    override fun A1.foo() {
        println("A1.foo in B1")
    }
}

fun main(args: Array<String>) {
    B().caller(A())    // A.foo in B
    B().caller(A1()) // A.foo in B
    B1().caller(A()) // A.foo in B1
    B1().caller(A1()) // A.foo in B1
}
```

## 数据类 data

-   数据类 data
    -   主构造函数至少有一个参数
    -   主构造函数所有参数需要标记为 val/var
    -   数据类不能是抽象，开放，密闭或者内部的
-   **从主构造函数中声明的所有属性导出以下成员**
    -   equals/hashCode/toString/componetN/copy,除非显示实现，否则只使用主构造函数中定义的属性
    -   copy()/componentN()，**不允许显示实现**
    -   componentN 按照声明的顺序对应于所有的属性
    -   **在 jvm 中，如果生成一的类需要一个无参的构造函数，则所有属性必须指定默认值**

```kotlin
// 为name指定默认值，可以使用无参构造函数
data class Person(var name: String = "Default") {
    var age: Int = 0
}

fun main(args: Array<String>) {
    val p = Person("Kotlin")
    p.age = 100
    // Person(name=Kotlin)，默认实现只会包含主构造函数中的参数
    println(p.toString())

    // 无参构造函数
    val p2 = Person()
    println(p2.toString())

    val p3 = Person()
    // true,equals函数只会参考主构造函数中的属性，所以这里name都为Default,也就是相等的
    println(p2 == p3)
}
```
